****grammar.y******

%{
package ast
%}

%type<body> body
%type<opt_body> opt_body
%type<stmt> stmt
%type<stmt_loop> stmt_loop
%type<funcProc> funcProc
%type<stmt_if> stmt_if
%type<opt_elseif_list> opt_elseif_list
%type<opt_else> opt_else
%type<stmt> opt_stmt
%type<stmt> opt_param
%type<exprs> exprs 
%type<stmt> expr
%type<opt_export> opt_export
%type<opt_directive> opt_directive 
%type<stmt> simple_expr
%type<declarations_method_params> declarations_method_params
%type<declarations_method_param> declarations_method_param
%type<stmt> opt_expr
%type<stmt> execute_param
%type<stmt> through_dot
%type<stmt> loopExp
%type<stmt> new_object
%type<stmt> ternary
%type<opt_explicit_variables> opt_explicit_variables
%type<explicit_variables> explicit_variables
%type<identifiers> identifiers
%type<stmt> stmt_tryCatch
%type<stmt> identifier
%type<goToLabel> goToLabel
%type<token> separator
%type<token> semicolon
%type<token> colon
%type<token> ':'
%type<token> ';'
%type<global_variables> global_variables



%union {
    token Token
    stmt_if *IfStatement
    opt_elseif_list []Statement
    opt_else []Statement
    stmt    Statement
    stmt_loop *LoopStatement
    funcProc *FunctionOrProcedure
    body []Statement
    opt_body []Statement
    declarations_method_params []ParamStatement
    declarations_method_param ParamStatement
    exprs []Statement
    opt_export *Token
    opt_directive *Token
    explicit_variables map[string]VarStatement
    global_variables []GlobalVariables
    opt_explicit_variables map[string]VarStatement
    identifiers []Token
    goToLabel *GoToLabelStatement
    opt_goToLabel *GoToLabelStatement
}

%token<token> Directive Identifier Procedure Var EndProcedure If Then ElseIf Else EndIf For Each In To Loop EndLoop Break Not ValueParam While GoToLabel
%token<token> Continue Try Catch EndTry Number String New Function EndFunction Return Throw NeEq Le Ge Or And True False Undefind Export Date GoTo Execute BuiltinFunction


//%right '='
%left Or
%left And
%left NeEq
%left Le
%left Ge
%left Not

%right '='
%left Identifier

//%nonassoc NeEq '>' '<'
//%nonassoc NeEq
//%nonassoc Not
%left '>' '<'
%left '+' '-'
%left '*' '/' '%'
%right UNARMinus UNARYPlus


%%

module: body {
         if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($1, yylex)
        }
    }
    | main_items opt_body {
         if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($2, yylex)
        }
    };

main_items: main
    | main_items main
;

main: global_variables {  
        if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($1, yylex)
        }
    }
    | funcProc {
        if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($1, yylex)
        }
    }
;

opt_directive:  { $$ = nil}
        | Directive { $$ = &$1}
;

opt_export: { $$ = nil}
        | Export { $$ = &$1}
;

global_variables: opt_directive Var identifiers opt_export semicolon { 
        $$ = make([]GlobalVariables,  len($3), len($3))
        for i, v := range $3 {
            if $1 != nil {
                $$[i].Directive = $1.literal
            }

            $$[i].Export = $4 != nil 
            $$[i].Var = VarStatement { Name: v.literal }
        }
};


funcProc: opt_directive Function Identifier '(' declarations_method_params ')' opt_export { isFunction(true, yylex) } opt_explicit_variables opt_body EndFunction
        {  
            $$ = createFunctionOrProcedure(PFTypeFunction, $1, $3.literal, $5, $7, $9, $10)
            isFunction(false, yylex) 
        }
        | opt_directive Procedure Identifier '(' declarations_method_params ')' opt_export opt_explicit_variables opt_body EndProcedure
        { 
            $$ = createFunctionOrProcedure(PFTypeProcedure, $1, $3.literal, $5, $7, $8, $9)
        }
;

opt_body: { $$ = nil }
	| body { $$ = $1 }
;
    

body: stmt { $$ = []Statement{$1} }
    | opt_body separator opt_stmt { 
        if $2.literal == ":" && len($1) > 0 {
            if _, ok := $1[len($1)-1].(*GoToLabelStatement); !ok {
                yylex.Error("semicolon (;) is expected")
            }
        }
        if $3 != nil {
            $$ = append($$, $3) 
        }
    }
    
;

opt_stmt: { $$ = nil }
        | stmt { $$ = $1 }
;

separator: semicolon { $$ = $1} | colon { $$ = $1};


/* переменные */ 
opt_explicit_variables: { $$ = map[string]VarStatement{} }
            | explicit_variables { $$ = $1 }
;

explicit_variables: Var identifiers semicolon { 
                    if vars, err := appendVarStatements(map[string]VarStatement{}, $2); err != nil {
                        yylex.Error(err.Error()) 
                    } else {
                        $$ = vars
                    }
                }
            | explicit_variables Var identifiers semicolon {
                    if vars, err := appendVarStatements($1, $3); err != nil {
                        yylex.Error(err.Error()) 
                    } else {
                        $$ = vars
                    }
                }
;


/* Если Конецесли */
stmt_if : If expr Then opt_body opt_elseif_list opt_else EndIf {  
    $$ = &IfStatement {
        Expression: $2,
        TrueBlock:  $4,
        IfElseBlock: $5,
        ElseBlock: $6,
    }
};

/* ИначеЕсли */
opt_elseif_list : { $$ = []Statement{} }
        | ElseIf expr Then opt_body opt_elseif_list { 
             $$ = append($5, &IfStatement{
                Expression: $2,
                TrueBlock:  $4,
            })
        };

/* Иначе */
opt_else : { $$ = nil }
        | Else opt_body { $$ = $2 };

/* тернарный оператор */
ternary: '?' '(' expr comma expr comma expr ')' { 
    $$ = TernaryStatement{
            Expression: $3,
            TrueBlock: $5,
            ElseBlock: $7,
        } 
};

/* циклы */
stmt_loop: For Each Identifier In loopExp Loop { setLoopFlag(true, yylex) } opt_body EndLoop {
        $$ = &LoopStatement{
            For: $3.literal,
            In: $5,
            Body: $8,
        }
        setLoopFlag(false, yylex) 
    } 
    | For expr To expr Loop { setLoopFlag(true, yylex) } opt_body EndLoop {
        $$ = &LoopStatement{
            For: $2,
            To: $4,
            Body: $7,
        }
        setLoopFlag(false, yylex)
    }
    |While expr Loop { setLoopFlag(true, yylex) } opt_body EndLoop {
        $$ = &LoopStatement{
            WhileExpr: $2,
            Body: $5,
        }
};


/* описыввает выражения которые можно использовать в циккле Для Каждого */
loopExp: through_dot { $$ = $1 }
        | new_object { $$ = $1 }
        |'(' new_object ')' { $$ = $2 }
;

stmt : expr { $$ = $1 }
    | stmt_if { $$ = $1 }
    | stmt_loop {$$ = $1 }
    | stmt_tryCatch { $$ = $1 }
    | Continue { $$ = ContinueStatement{}; checkLoopOperator($1, yylex) }
    | Break { $$ = BreakStatement{}; checkLoopOperator($1, yylex) }
    | Throw opt_param { $$ = ThrowStatement{ Param: $2 }; checkThrowParam($1, $2, yylex) }
    | Return opt_expr { $$ = &ReturnStatement{ Param: $2 }; checkReturnParam($2, yylex) }
;

opt_param: { $$ = nil } 
            | expr { $$ = $1 }
;


/* вызовы через точку */
through_dot: identifier { $$ = $1 }
        | through_dot dot identifier { $$ = CallChainStatement{ Unit: $3, Call:  $1 } }
;

/* вызовы процедур, функций */
/* вызовы выполнить */
/* выполнить может вызываться так выполнить("что-то") или так выполнить "что-то" */
identifier: Identifier { $$ = VarStatement{ Name: $1.literal } }
        | Identifier '(' exprs ')' { $$ = MethodStatement{ Name: $1.literal, Param: $3 } }
        | identifier '[' expr ']' { $$ = ItemStatement{ Object: $1, Item: $3 } }
        | Execute execute_param { $$ = MethodStatement{ Name: $1.literal, Param: []Statement{$2} } }
        | Execute '(' expr ')' { $$ = MethodStatement{ Name: $1.literal, Param:  []Statement{$3} } }
        | BuiltinFunction '(' exprs ')' { $$ = &BuiltinFunctionStatement{ Name: $1.literal, Param: $3 } }
;

execute_param: String { $$ = $1.value  }
             | Identifier { $$ = VarStatement{ Name: $1.literal }};

/* попытка */
stmt_tryCatch: Try opt_body Catch { setTryFlag(true, yylex) } opt_body EndTry { 
    $$ = TryStatement{ Body: $2, Catch: $5 }
    setTryFlag(false, yylex)
};

/* выражения */
expr : simple_expr { $$ = $1 }
    |'(' expr ')' { $$ = $2 }
    | expr '+' expr { $$ = &ExpStatement{Operation: OpPlus, Left: $1, Right: $3} }
    | expr '-' expr { $$ = &ExpStatement{Operation: OpMinus, Left: $1, Right: $3} }
    | expr '*' expr { $$ = &ExpStatement{Operation: OpMul, Left: $1, Right: $3} }
    | expr '/' expr { $$ = &ExpStatement{Operation: OpDiv, Left: $1, Right: $3} }
    | expr '%' expr { $$ = &ExpStatement{Operation: OpMod, Left: $1, Right: $3} }
    | expr '>' expr { $$ = &ExpStatement{Operation: OpGt, Left: $1, Right: $3} }
    | expr '<' expr { $$ = &ExpStatement{Operation: OpLt, Left: $1, Right: $3} }
	| expr '=' expr { $$ = &ExpStatement{Operation: OpEq, Left: $1, Right: $3 } }
    | expr Or expr {  $$ = &ExpStatement{Operation: OpOr, Left: $1, Right: $3 } } 
    | expr And expr { $$ = &ExpStatement{Operation: OpAnd, Left: $1, Right: $3 } } 
    | expr NeEq expr { $$ = &ExpStatement{Operation: OpNe, Left: $1, Right: $3 } }
    | expr Le expr { $$ = &ExpStatement{Operation: OpLe, Left: $1, Right: $3 } }
    | expr Ge expr { $$ = &ExpStatement{Operation: OpGe, Left: $1, Right: $3 } }
    | Not expr { $$ = not($2) }
    | new_object { $$ = $1 } 
    | GoTo goToLabel { $$ = GoToStatement{ Label: $2 } }
;

opt_expr: { $$ = nil } | expr { $$ = $1 };

// опиасываются правила по которым можно объявлять параметры в функции или процедуре
declarations_method_param: Identifier {  $$ = *(&ParamStatement{}).Fill(nil, $1) } // обычный параметр
            | ValueParam Identifier { $$ = *(&ParamStatement{}).Fill(&$1, $2) } // знач
            | declarations_method_param '=' simple_expr { $$ = *($$.DefaultValue($3)) } // необязательный параметр 
;

declarations_method_params : { $$ = []ParamStatement{} }
                | declarations_method_param  { $$ = []ParamStatement{$1} }
                | declarations_method_params comma declarations_method_param { $$ = append($1, $3) }
;

// для ключевого слова Новый
// 1С допускает такие конструкции
// новый Структура(), новый Массив() ...
// но так же и такие
// Новый("РегистрСведенийКлючЗаписи.СостоянияОригиналовПервичныхДокументов", ПараметрыМассив);
new_object:  New Identifier { $$ = NewObjectStatement{ Constructor: $2.literal } }
            | New Identifier '(' exprs ')' { $$ = NewObjectStatement{ Constructor: $2.literal, Param: $4 } }
            | New '(' exprs ')' { $$ = NewObjectStatement{ Param: $3 } }
;

simple_expr:  String { $$ = $1.value  }
            | Number { $$ =  $1.value }
            | '-' expr %prec UNARMinus { $$ = unaryMinus($2) }
            | '+' expr %prec UNARYPlus { $$ = $2 }
            | True { $$ =  $1.value  }
            | False { $$ =  $1.value  }
            | Date { $$ =  $1.value  }
            | Undefind { $$ = UndefinedStatement{} }
            | goToLabel { $$ = $1}
            | through_dot { 
                if tok, ok := $1.(Token); ok {
                    $$ = tok.literal
                } else {
                    $$ =  $1
                }
            }
            | ternary { $$ =  $1  } // тернарный оператор
;

goToLabel: GoToLabel { $$ = &GoToLabelStatement{ Name: $1.literal } }

exprs : opt_expr {$$ = []Statement{$1} }
	| exprs comma opt_expr { $$ = append($$, $3);  }
;    

identifiers: Identifier { $$ = []Token{$1} }
        | identifiers comma Identifier {$$ = append($$, $3) }
;

semicolon: ';' {$$ = $1};
colon: ':'{$$ = $1};
comma: ',';
dot: '.';

%%



****y.output******


state 0
	$accept: .module $end 
	opt_body: .    (15)
	opt_directive: .    (7)

	':'  reduce 15 (src line 151)
	';'  reduce 15 (src line 151)
	Directive  shift 39
	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 7 (src line 119)

	body  goto 2
	opt_body  goto 5
	stmt  goto 4
	stmt_loop  goto 9
	funcProc  goto 16
	stmt_if  goto 8
	expr  goto 7
	opt_directive  goto 26
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35
	global_variables  goto 15
	module  goto 1
	main_items  goto 3
	main  goto 6

state 1
	$accept:  module.$end 

	$end  accept
	.  error


state 2
	module:  body.    (1)
	opt_body:  body.    (16)

	$end  reduce 1 (src line 92)
	.  reduce 16 (src line 152)


state 3
	module:  main_items.opt_body 
	main_items:  main_items.main 
	opt_body: .    (15)
	opt_directive: .    (7)

	Directive  shift 39
	Identifier  shift 43
	Procedure  reduce 7 (src line 119)
	Var  reduce 7 (src line 119)
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Function  reduce 7 (src line 119)
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 46
	stmt  goto 4
	stmt_loop  goto 9
	funcProc  goto 16
	stmt_if  goto 8
	expr  goto 7
	opt_directive  goto 26
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35
	global_variables  goto 15
	main  goto 47

state 4
	body:  stmt.    (17)

	.  reduce 17 (src line 156)


state 5
	body:  opt_body.separator opt_stmt 

	':'  shift 53
	';'  shift 52
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 6
	main_items:  main.    (3)

	.  reduce 3 (src line 103)


state 7
	stmt:  expr.    (42)
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 42 (src line 262)


state 8
	stmt:  stmt_if.    (43)

	.  reduce 43 (src line 263)


state 9
	stmt:  stmt_loop.    (44)

	.  reduce 44 (src line 264)


state 10
	stmt:  stmt_tryCatch.    (45)

	.  reduce 45 (src line 265)


state 11
	stmt:  Continue.    (46)

	.  reduce 46 (src line 266)


state 12
	stmt:  Break.    (47)

	.  reduce 47 (src line 267)


state 13
	stmt:  Throw.opt_param 
	opt_param: .    (50)

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 50 (src line 272)

	opt_param  goto 67
	expr  goto 68
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 14
	stmt:  Return.opt_expr 
	opt_expr: .    (82)

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 82 (src line 323)

	expr  goto 70
	simple_expr  goto 17
	opt_expr  goto 69
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 15
	main:  global_variables.    (5)

	.  reduce 5 (src line 107)


state 16
	main:  funcProc.    (6)

	.  reduce 6 (src line 112)


state 17
	expr:  simple_expr.    (64)

	.  reduce 64 (src line 303)


state 18
	expr:  '('.expr ')' 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 71
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 19
	expr:  Not.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 72
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 20
	expr:  new_object.    (80)

	.  reduce 80 (src line 319)


state 21
	expr:  GoTo.goToLabel 

	GoToLabel  shift 40
	.  error

	goToLabel  goto 73

state 22
	stmt_if:  If.expr Then opt_body opt_elseif_list opt_else EndIf 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 74
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 23
	stmt_loop:  For.Each Identifier In loopExp Loop $$33 opt_body EndLoop 
	stmt_loop:  For.expr To expr Loop $$35 opt_body EndLoop 

	Identifier  shift 43
	Each  shift 75
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 76
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 24
	stmt_loop:  While.expr Loop $$37 opt_body EndLoop 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 77
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 25
	stmt_tryCatch:  Try.opt_body Catch $$62 opt_body EndTry 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 78
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 26
	global_variables:  opt_directive.Var identifiers opt_export semicolon 
	funcProc:  opt_directive.Function Identifier '(' declarations_method_params ')' opt_export $$12 opt_explicit_variables opt_body EndFunction 
	funcProc:  opt_directive.Procedure Identifier '(' declarations_method_params ')' opt_export opt_explicit_variables opt_body EndProcedure 

	Procedure  shift 81
	Var  shift 79
	Function  shift 80
	.  error


state 27
	simple_expr:  String.    (93)

	.  reduce 93 (src line 346)


state 28
	simple_expr:  Number.    (94)

	.  reduce 94 (src line 347)


state 29
	simple_expr:  '-'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 82
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 30
	simple_expr:  '+'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 83
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 31
	simple_expr:  True.    (97)

	.  reduce 97 (src line 350)


state 32
	simple_expr:  False.    (98)

	.  reduce 98 (src line 351)


state 33
	simple_expr:  Date.    (99)

	.  reduce 99 (src line 352)


state 34
	simple_expr:  Undefind.    (100)

	.  reduce 100 (src line 353)


state 35
	simple_expr:  goToLabel.    (101)

	.  reduce 101 (src line 354)


state 36
	through_dot:  through_dot.dot identifier 
	simple_expr:  through_dot.    (102)

	'.'  shift 85
	.  reduce 102 (src line 355)

	dot  goto 84

state 37
	simple_expr:  ternary.    (103)

	.  reduce 103 (src line 362)


state 38
	new_object:  New.Identifier 
	new_object:  New.Identifier '(' exprs ')' 
	new_object:  New.'(' exprs ')' 

	Identifier  shift 86
	'('  shift 87
	.  error


state 39
	opt_directive:  Directive.    (8)

	.  reduce 8 (src line 120)


state 40
	goToLabel:  GoToLabel.    (104)

	.  reduce 104 (src line 365)


state 41
	through_dot:  identifier.    (52)
	identifier:  identifier.'[' expr ']' 

	'['  shift 88
	.  reduce 52 (src line 278)


state 42
	ternary:  '?'.'(' expr comma expr comma expr ')' 

	'('  shift 89
	.  error


state 43
	identifier:  Identifier.    (54)
	identifier:  Identifier.'(' exprs ')' 

	'('  shift 90
	.  reduce 54 (src line 285)


state 44
	identifier:  Execute.execute_param 
	identifier:  Execute.'(' expr ')' 

	Identifier  shift 94
	String  shift 93
	'('  shift 92
	.  error

	execute_param  goto 91

state 45
	identifier:  BuiltinFunction.'(' exprs ')' 

	'('  shift 95
	.  error


state 46
	module:  main_items opt_body.    (2)
	body:  opt_body.separator opt_stmt 

	':'  shift 53
	';'  shift 52
	.  reduce 2 (src line 97)

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 47
	main_items:  main_items main.    (4)

	.  reduce 4 (src line 104)


state 48
	opt_body:  body.    (16)

	.  reduce 16 (src line 152)


state 49
	body:  opt_body separator.opt_stmt 
	opt_stmt: .    (19)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 19 (src line 170)

	stmt  goto 97
	stmt_loop  goto 9
	stmt_if  goto 8
	opt_stmt  goto 96
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 50
	separator:  semicolon.    (21)

	.  reduce 21 (src line 174)


state 51
	separator:  colon.    (22)

	.  reduce 22 (src line 174)


state 52
	semicolon:  ';'.    (109)

	.  reduce 109 (src line 375)


state 53
	colon:  ':'.    (110)

	.  reduce 110 (src line 376)


state 54
	expr:  expr '+'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 98
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 55
	expr:  expr '-'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 99
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 56
	expr:  expr '*'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 100
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 57
	expr:  expr '/'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 101
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 58
	expr:  expr '%'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 102
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 59
	expr:  expr '>'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 103
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 60
	expr:  expr '<'.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 104
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 61
	expr:  expr '='.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 105
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 62
	expr:  expr Or.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 106
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 63
	expr:  expr And.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 107
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 64
	expr:  expr NeEq.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 108
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 65
	expr:  expr Le.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 109
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 66
	expr:  expr Ge.expr 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 110
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 67
	stmt:  Throw opt_param.    (48)

	.  reduce 48 (src line 268)


state 68
	opt_param:  expr.    (51)
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 51 (src line 273)


state 69
	stmt:  Return opt_expr.    (49)

	.  reduce 49 (src line 269)


state 70
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 
	opt_expr:  expr.    (83)

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 83 (src line 323)


state 71
	expr:  '(' expr.')' 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	')'  shift 111
	.  error


state 72
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 
	expr:  Not expr.    (79)

	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 79 (src line 318)


state 73
	expr:  GoTo goToLabel.    (81)

	.  reduce 81 (src line 320)


state 74
	stmt_if:  If expr.Then opt_body opt_elseif_list opt_else EndIf 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	Then  shift 112
	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  error


state 75
	stmt_loop:  For Each.Identifier In loopExp Loop $$33 opt_body EndLoop 

	Identifier  shift 113
	.  error


state 76
	stmt_loop:  For expr.To expr Loop $$35 opt_body EndLoop 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	To  shift 114
	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  error


state 77
	stmt_loop:  While expr.Loop $$37 opt_body EndLoop 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	Loop  shift 115
	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  error


state 78
	body:  opt_body.separator opt_stmt 
	stmt_tryCatch:  Try opt_body.Catch $$62 opt_body EndTry 

	':'  shift 53
	';'  shift 52
	Catch  shift 116
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 79
	global_variables:  opt_directive Var.identifiers opt_export semicolon 

	Identifier  shift 118
	.  error

	identifiers  goto 117

state 80
	funcProc:  opt_directive Function.Identifier '(' declarations_method_params ')' opt_export $$12 opt_explicit_variables opt_body EndFunction 

	Identifier  shift 119
	.  error


state 81
	funcProc:  opt_directive Procedure.Identifier '(' declarations_method_params ')' opt_export opt_explicit_variables opt_body EndProcedure 

	Identifier  shift 120
	.  error


state 82
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 
	simple_expr:  '-' expr.    (95)

	.  reduce 95 (src line 348)


state 83
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 
	simple_expr:  '+' expr.    (96)

	.  reduce 96 (src line 349)


state 84
	through_dot:  through_dot dot.identifier 

	Identifier  shift 43
	Execute  shift 44
	BuiltinFunction  shift 45
	.  error

	identifier  goto 121

state 85
	dot:  '.'.    (112)

	.  reduce 112 (src line 378)


state 86
	new_object:  New Identifier.    (90)
	new_object:  New Identifier.'(' exprs ')' 

	'('  shift 122
	.  reduce 90 (src line 341)


state 87
	new_object:  New '('.exprs ')' 
	opt_expr: .    (82)

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 82 (src line 323)

	exprs  goto 123
	expr  goto 70
	simple_expr  goto 17
	opt_expr  goto 124
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 88
	identifier:  identifier '['.expr ']' 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 125
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 89
	ternary:  '?' '('.expr comma expr comma expr ')' 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 126
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 90
	identifier:  Identifier '('.exprs ')' 
	opt_expr: .    (82)

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 82 (src line 323)

	exprs  goto 127
	expr  goto 70
	simple_expr  goto 17
	opt_expr  goto 124
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 91
	identifier:  Execute execute_param.    (57)

	.  reduce 57 (src line 288)


state 92
	identifier:  Execute '('.expr ')' 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 128
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 93
	execute_param:  String.    (60)

	.  reduce 60 (src line 293)


state 94
	execute_param:  Identifier.    (61)

	.  reduce 61 (src line 294)


state 95
	identifier:  BuiltinFunction '('.exprs ')' 
	opt_expr: .    (82)

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 82 (src line 323)

	exprs  goto 129
	expr  goto 70
	simple_expr  goto 17
	opt_expr  goto 124
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 96
	body:  opt_body separator opt_stmt.    (18)

	.  reduce 18 (src line 157)


state 97
	opt_stmt:  stmt.    (20)

	.  reduce 20 (src line 171)


state 98
	expr:  expr.'+' expr 
	expr:  expr '+' expr.    (66)
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 66 (src line 305)


state 99
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr '-' expr.    (67)
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 67 (src line 306)


state 100
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr '*' expr.    (68)
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	.  reduce 68 (src line 307)


state 101
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr '/' expr.    (69)
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	.  reduce 69 (src line 308)


state 102
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr '%' expr.    (70)
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	.  reduce 70 (src line 309)


state 103
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr '>' expr.    (71)
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 71 (src line 310)


state 104
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr '<' expr.    (72)
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 72 (src line 311)


state 105
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr '=' expr.    (73)
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 73 (src line 312)


state 106
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr Or expr.    (74)
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 74 (src line 313)


state 107
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr And expr.    (75)
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 75 (src line 314)


state 108
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr NeEq expr.    (76)
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	Le  shift 65
	Ge  shift 66
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 76 (src line 315)


state 109
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr Le expr.    (77)
	expr:  expr.Ge expr 

	Ge  shift 66
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 77 (src line 316)


state 110
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 
	expr:  expr Ge expr.    (78)

	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  reduce 78 (src line 317)


state 111
	expr:  '(' expr ')'.    (65)

	.  reduce 65 (src line 304)


state 112
	stmt_if:  If expr Then.opt_body opt_elseif_list opt_else EndIf 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 130
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 113
	stmt_loop:  For Each Identifier.In loopExp Loop $$33 opt_body EndLoop 

	In  shift 131
	.  error


state 114
	stmt_loop:  For expr To.expr Loop $$35 opt_body EndLoop 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 132
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 115
	stmt_loop:  While expr Loop.$$37 opt_body EndLoop 
	$$37: .    (37)

	.  reduce 37 (src line 248)

	$$37  goto 133

state 116
	stmt_tryCatch:  Try opt_body Catch.$$62 opt_body EndTry 
	$$62: .    (62)

	.  reduce 62 (src line 297)

	$$62  goto 134

state 117
	global_variables:  opt_directive Var identifiers.opt_export semicolon 
	identifiers:  identifiers.comma Identifier 
	opt_export: .    (9)

	Export  shift 137
	','  shift 138
	.  reduce 9 (src line 123)

	opt_export  goto 135
	comma  goto 136

state 118
	identifiers:  Identifier.    (107)

	.  reduce 107 (src line 371)


state 119
	funcProc:  opt_directive Function Identifier.'(' declarations_method_params ')' opt_export $$12 opt_explicit_variables opt_body EndFunction 

	'('  shift 139
	.  error


state 120
	funcProc:  opt_directive Procedure Identifier.'(' declarations_method_params ')' opt_export opt_explicit_variables opt_body EndProcedure 

	'('  shift 140
	.  error


state 121
	through_dot:  through_dot dot identifier.    (53)
	identifier:  identifier.'[' expr ']' 

	'['  shift 88
	.  reduce 53 (src line 279)


state 122
	new_object:  New Identifier '('.exprs ')' 
	opt_expr: .    (82)

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 82 (src line 323)

	exprs  goto 141
	expr  goto 70
	simple_expr  goto 17
	opt_expr  goto 124
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 123
	new_object:  New '(' exprs.')' 
	exprs:  exprs.comma opt_expr 

	')'  shift 142
	','  shift 138
	.  error

	comma  goto 143

state 124
	exprs:  opt_expr.    (105)

	.  reduce 105 (src line 367)


state 125
	identifier:  identifier '[' expr.']' 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	']'  shift 144
	.  error


state 126
	ternary:  '?' '(' expr.comma expr comma expr ')' 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	','  shift 138
	.  error

	comma  goto 145

state 127
	identifier:  Identifier '(' exprs.')' 
	exprs:  exprs.comma opt_expr 

	')'  shift 146
	','  shift 138
	.  error

	comma  goto 143

state 128
	identifier:  Execute '(' expr.')' 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	')'  shift 147
	.  error


state 129
	identifier:  BuiltinFunction '(' exprs.')' 
	exprs:  exprs.comma opt_expr 

	')'  shift 148
	','  shift 138
	.  error

	comma  goto 143

state 130
	body:  opt_body.separator opt_stmt 
	stmt_if:  If expr Then opt_body.opt_elseif_list opt_else EndIf 
	opt_elseif_list: .    (28)

	':'  shift 53
	';'  shift 52
	ElseIf  shift 150
	.  reduce 28 (src line 210)

	opt_elseif_list  goto 149
	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 131
	stmt_loop:  For Each Identifier In.loopExp Loop $$33 opt_body EndLoop 

	Identifier  shift 43
	New  shift 38
	Execute  shift 44
	BuiltinFunction  shift 45
	'('  shift 154
	.  error

	through_dot  goto 152
	loopExp  goto 151
	new_object  goto 153
	identifier  goto 41

state 132
	stmt_loop:  For expr To expr.Loop $$35 opt_body EndLoop 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	Loop  shift 155
	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  error


state 133
	stmt_loop:  While expr Loop $$37.opt_body EndLoop 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 156
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 134
	stmt_tryCatch:  Try opt_body Catch $$62.opt_body EndTry 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 157
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 135
	global_variables:  opt_directive Var identifiers opt_export.semicolon 

	';'  shift 52
	.  error

	semicolon  goto 158

state 136
	identifiers:  identifiers comma.Identifier 

	Identifier  shift 159
	.  error


state 137
	opt_export:  Export.    (10)

	.  reduce 10 (src line 124)


state 138
	comma:  ','.    (111)

	.  reduce 111 (src line 377)


state 139
	funcProc:  opt_directive Function Identifier '('.declarations_method_params ')' opt_export $$12 opt_explicit_variables opt_body EndFunction 
	declarations_method_params: .    (87)

	Identifier  shift 162
	ValueParam  shift 163
	.  reduce 87 (src line 331)

	declarations_method_params  goto 160
	declarations_method_param  goto 161

state 140
	funcProc:  opt_directive Procedure Identifier '('.declarations_method_params ')' opt_export opt_explicit_variables opt_body EndProcedure 
	declarations_method_params: .    (87)

	Identifier  shift 162
	ValueParam  shift 163
	.  reduce 87 (src line 331)

	declarations_method_params  goto 164
	declarations_method_param  goto 161

state 141
	new_object:  New Identifier '(' exprs.')' 
	exprs:  exprs.comma opt_expr 

	')'  shift 165
	','  shift 138
	.  error

	comma  goto 143

state 142
	new_object:  New '(' exprs ')'.    (92)

	.  reduce 92 (src line 343)


state 143
	exprs:  exprs comma.opt_expr 
	opt_expr: .    (82)

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 82 (src line 323)

	expr  goto 70
	simple_expr  goto 17
	opt_expr  goto 166
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 144
	identifier:  identifier '[' expr ']'.    (56)

	.  reduce 56 (src line 287)


state 145
	ternary:  '?' '(' expr comma.expr comma expr ')' 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 167
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 146
	identifier:  Identifier '(' exprs ')'.    (55)

	.  reduce 55 (src line 286)


state 147
	identifier:  Execute '(' expr ')'.    (58)

	.  reduce 58 (src line 289)


state 148
	identifier:  BuiltinFunction '(' exprs ')'.    (59)

	.  reduce 59 (src line 290)


state 149
	stmt_if:  If expr Then opt_body opt_elseif_list.opt_else EndIf 
	opt_else: .    (30)

	Else  shift 169
	.  reduce 30 (src line 219)

	opt_else  goto 168

state 150
	opt_elseif_list:  ElseIf.expr Then opt_body opt_elseif_list 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 170
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 151
	stmt_loop:  For Each Identifier In loopExp.Loop $$33 opt_body EndLoop 

	Loop  shift 171
	.  error


state 152
	loopExp:  through_dot.    (39)
	through_dot:  through_dot.dot identifier 

	'.'  shift 85
	.  reduce 39 (src line 257)

	dot  goto 84

state 153
	loopExp:  new_object.    (40)

	.  reduce 40 (src line 258)


state 154
	loopExp:  '('.new_object ')' 

	New  shift 38
	.  error

	new_object  goto 172

state 155
	stmt_loop:  For expr To expr Loop.$$35 opt_body EndLoop 
	$$35: .    (35)

	.  reduce 35 (src line 240)

	$$35  goto 173

state 156
	body:  opt_body.separator opt_stmt 
	stmt_loop:  While expr Loop $$37 opt_body.EndLoop 

	':'  shift 53
	';'  shift 52
	EndLoop  shift 174
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 157
	body:  opt_body.separator opt_stmt 
	stmt_tryCatch:  Try opt_body Catch $$62 opt_body.EndTry 

	':'  shift 53
	';'  shift 52
	EndTry  shift 175
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 158
	global_variables:  opt_directive Var identifiers opt_export semicolon.    (11)

	.  reduce 11 (src line 127)


state 159
	identifiers:  identifiers comma Identifier.    (108)

	.  reduce 108 (src line 372)


state 160
	funcProc:  opt_directive Function Identifier '(' declarations_method_params.')' opt_export $$12 opt_explicit_variables opt_body EndFunction 
	declarations_method_params:  declarations_method_params.comma declarations_method_param 

	')'  shift 176
	','  shift 138
	.  error

	comma  goto 177

state 161
	declarations_method_param:  declarations_method_param.'=' simple_expr 
	declarations_method_params:  declarations_method_param.    (88)

	'='  shift 178
	.  reduce 88 (src line 332)


state 162
	declarations_method_param:  Identifier.    (84)

	.  reduce 84 (src line 326)


state 163
	declarations_method_param:  ValueParam.Identifier 

	Identifier  shift 179
	.  error


state 164
	funcProc:  opt_directive Procedure Identifier '(' declarations_method_params.')' opt_export opt_explicit_variables opt_body EndProcedure 
	declarations_method_params:  declarations_method_params.comma declarations_method_param 

	')'  shift 180
	','  shift 138
	.  error

	comma  goto 177

state 165
	new_object:  New Identifier '(' exprs ')'.    (91)

	.  reduce 91 (src line 342)


state 166
	exprs:  exprs comma opt_expr.    (106)

	.  reduce 106 (src line 368)


state 167
	ternary:  '?' '(' expr comma expr.comma expr ')' 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	','  shift 138
	.  error

	comma  goto 181

state 168
	stmt_if:  If expr Then opt_body opt_elseif_list opt_else.EndIf 

	EndIf  shift 182
	.  error


state 169
	opt_else:  Else.opt_body 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 183
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 170
	opt_elseif_list:  ElseIf expr.Then opt_body opt_elseif_list 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	Then  shift 184
	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	.  error


state 171
	stmt_loop:  For Each Identifier In loopExp Loop.$$33 opt_body EndLoop 
	$$33: .    (33)

	.  reduce 33 (src line 232)

	$$33  goto 185

state 172
	loopExp:  '(' new_object.')' 

	')'  shift 186
	.  error


state 173
	stmt_loop:  For expr To expr Loop $$35.opt_body EndLoop 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 187
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 174
	stmt_loop:  While expr Loop $$37 opt_body EndLoop.    (38)

	.  reduce 38 (src line 248)


state 175
	stmt_tryCatch:  Try opt_body Catch $$62 opt_body EndTry.    (63)

	.  reduce 63 (src line 297)


state 176
	funcProc:  opt_directive Function Identifier '(' declarations_method_params ')'.opt_export $$12 opt_explicit_variables opt_body EndFunction 
	opt_export: .    (9)

	Export  shift 137
	.  reduce 9 (src line 123)

	opt_export  goto 188

state 177
	declarations_method_params:  declarations_method_params comma.declarations_method_param 

	Identifier  shift 162
	ValueParam  shift 163
	.  error

	declarations_method_param  goto 189

state 178
	declarations_method_param:  declarations_method_param '='.simple_expr 

	Identifier  shift 43
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'?'  shift 42
	.  error

	simple_expr  goto 190
	through_dot  goto 36
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 179
	declarations_method_param:  ValueParam Identifier.    (85)

	.  reduce 85 (src line 327)


state 180
	funcProc:  opt_directive Procedure Identifier '(' declarations_method_params ')'.opt_export opt_explicit_variables opt_body EndProcedure 
	opt_export: .    (9)

	Export  shift 137
	.  reduce 9 (src line 123)

	opt_export  goto 191

state 181
	ternary:  '?' '(' expr comma expr comma.expr ')' 

	Identifier  shift 43
	Not  shift 19
	GoToLabel  shift 40
	Number  shift 28
	String  shift 27
	New  shift 38
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  error

	expr  goto 192
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	identifier  goto 41
	goToLabel  goto 35

state 182
	stmt_if:  If expr Then opt_body opt_elseif_list opt_else EndIf.    (27)

	.  reduce 27 (src line 200)


state 183
	body:  opt_body.separator opt_stmt 
	opt_else:  Else opt_body.    (31)

	':'  shift 53
	';'  shift 52
	.  reduce 31 (src line 220)

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 184
	opt_elseif_list:  ElseIf expr Then.opt_body opt_elseif_list 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 193
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 185
	stmt_loop:  For Each Identifier In loopExp Loop $$33.opt_body EndLoop 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 194
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 186
	loopExp:  '(' new_object ')'.    (41)

	.  reduce 41 (src line 259)


state 187
	body:  opt_body.separator opt_stmt 
	stmt_loop:  For expr To expr Loop $$35 opt_body.EndLoop 

	':'  shift 53
	';'  shift 52
	EndLoop  shift 195
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 188
	funcProc:  opt_directive Function Identifier '(' declarations_method_params ')' opt_export.$$12 opt_explicit_variables opt_body EndFunction 
	$$12: .    (12)

	.  reduce 12 (src line 140)

	$$12  goto 196

state 189
	declarations_method_param:  declarations_method_param.'=' simple_expr 
	declarations_method_params:  declarations_method_params comma declarations_method_param.    (89)

	'='  shift 178
	.  reduce 89 (src line 333)


state 190
	declarations_method_param:  declarations_method_param '=' simple_expr.    (86)

	.  reduce 86 (src line 328)


state 191
	funcProc:  opt_directive Procedure Identifier '(' declarations_method_params ')' opt_export.opt_explicit_variables opt_body EndProcedure 
	opt_explicit_variables: .    (23)

	Var  shift 199
	.  reduce 23 (src line 178)

	opt_explicit_variables  goto 197
	explicit_variables  goto 198

state 192
	ternary:  '?' '(' expr comma expr comma expr.')' 
	expr:  expr.'+' expr 
	expr:  expr.'-' expr 
	expr:  expr.'*' expr 
	expr:  expr.'/' expr 
	expr:  expr.'%' expr 
	expr:  expr.'>' expr 
	expr:  expr.'<' expr 
	expr:  expr.'=' expr 
	expr:  expr.Or expr 
	expr:  expr.And expr 
	expr:  expr.NeEq expr 
	expr:  expr.Le expr 
	expr:  expr.Ge expr 

	NeEq  shift 64
	Le  shift 65
	Ge  shift 66
	Or  shift 62
	And  shift 63
	'='  shift 61
	'>'  shift 59
	'<'  shift 60
	'+'  shift 54
	'-'  shift 55
	'*'  shift 56
	'/'  shift 57
	'%'  shift 58
	')'  shift 200
	.  error


state 193
	body:  opt_body.separator opt_stmt 
	opt_elseif_list:  ElseIf expr Then opt_body.opt_elseif_list 
	opt_elseif_list: .    (28)

	':'  shift 53
	';'  shift 52
	ElseIf  shift 150
	.  reduce 28 (src line 210)

	opt_elseif_list  goto 201
	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 194
	body:  opt_body.separator opt_stmt 
	stmt_loop:  For Each Identifier In loopExp Loop $$33 opt_body.EndLoop 

	':'  shift 53
	';'  shift 52
	EndLoop  shift 202
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 195
	stmt_loop:  For expr To expr Loop $$35 opt_body EndLoop.    (36)

	.  reduce 36 (src line 240)


state 196
	funcProc:  opt_directive Function Identifier '(' declarations_method_params ')' opt_export $$12.opt_explicit_variables opt_body EndFunction 
	opt_explicit_variables: .    (23)

	Var  shift 199
	.  reduce 23 (src line 178)

	opt_explicit_variables  goto 203
	explicit_variables  goto 198

state 197
	funcProc:  opt_directive Procedure Identifier '(' declarations_method_params ')' opt_export opt_explicit_variables.opt_body EndProcedure 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 204
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 198
	opt_explicit_variables:  explicit_variables.    (24)
	explicit_variables:  explicit_variables.Var identifiers semicolon 

	Var  shift 205
	.  reduce 24 (src line 179)


state 199
	explicit_variables:  Var.identifiers semicolon 

	Identifier  shift 118
	.  error

	identifiers  goto 206

state 200
	ternary:  '?' '(' expr comma expr comma expr ')'.    (32)

	.  reduce 32 (src line 223)


state 201
	opt_elseif_list:  ElseIf expr Then opt_body opt_elseif_list.    (29)

	.  reduce 29 (src line 211)


state 202
	stmt_loop:  For Each Identifier In loopExp Loop $$33 opt_body EndLoop.    (34)

	.  reduce 34 (src line 232)


state 203
	funcProc:  opt_directive Function Identifier '(' declarations_method_params ')' opt_export $$12 opt_explicit_variables.opt_body EndFunction 
	opt_body: .    (15)

	Identifier  shift 43
	If  shift 22
	For  shift 23
	Break  shift 12
	Not  shift 19
	While  shift 24
	GoToLabel  shift 40
	Continue  shift 11
	Try  shift 25
	Number  shift 28
	String  shift 27
	New  shift 38
	Return  shift 14
	Throw  shift 13
	True  shift 31
	False  shift 32
	Undefind  shift 34
	Date  shift 33
	GoTo  shift 21
	Execute  shift 44
	BuiltinFunction  shift 45
	'+'  shift 30
	'-'  shift 29
	'('  shift 18
	'?'  shift 42
	.  reduce 15 (src line 151)

	body  goto 48
	opt_body  goto 207
	stmt  goto 4
	stmt_loop  goto 9
	stmt_if  goto 8
	expr  goto 7
	simple_expr  goto 17
	through_dot  goto 36
	new_object  goto 20
	ternary  goto 37
	stmt_tryCatch  goto 10
	identifier  goto 41
	goToLabel  goto 35

state 204
	funcProc:  opt_directive Procedure Identifier '(' declarations_method_params ')' opt_export opt_explicit_variables opt_body.EndProcedure 
	body:  opt_body.separator opt_stmt 

	':'  shift 53
	';'  shift 52
	EndProcedure  shift 208
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 205
	explicit_variables:  explicit_variables Var.identifiers semicolon 

	Identifier  shift 118
	.  error

	identifiers  goto 209

state 206
	explicit_variables:  Var identifiers.semicolon 
	identifiers:  identifiers.comma Identifier 

	';'  shift 52
	','  shift 138
	.  error

	semicolon  goto 210
	comma  goto 136

state 207
	funcProc:  opt_directive Function Identifier '(' declarations_method_params ')' opt_export $$12 opt_explicit_variables opt_body.EndFunction 
	body:  opt_body.separator opt_stmt 

	':'  shift 53
	';'  shift 52
	EndFunction  shift 211
	.  error

	separator  goto 49
	semicolon  goto 50
	colon  goto 51

state 208
	funcProc:  opt_directive Procedure Identifier '(' declarations_method_params ')' opt_export opt_explicit_variables opt_body EndProcedure.    (14)

	.  reduce 14 (src line 145)


state 209
	explicit_variables:  explicit_variables Var identifiers.semicolon 
	identifiers:  identifiers.comma Identifier 

	';'  shift 52
	','  shift 138
	.  error

	semicolon  goto 212
	comma  goto 136

state 210
	explicit_variables:  Var identifiers semicolon.    (25)

	.  reduce 25 (src line 182)


state 211
	funcProc:  opt_directive Function Identifier '(' declarations_method_params ')' opt_export $$12 opt_explicit_variables opt_body EndFunction.    (13)

	.  reduce 13 (src line 140)


state 212
	explicit_variables:  explicit_variables Var identifiers semicolon.    (26)

	.  reduce 26 (src line 189)


67 terminals, 44 nonterminals
113 grammar rules, 213/16000 states
0 shift/reduce, 0 reduce/reduce conflicts reported
93 working sets used
memory: parser 690/240000
144 extra closures
1300 shift entries, 7 exceptions
120 goto entries
395 entries saved by goto default
Optimizer space used: output 628/240000
628 table entries, 112 zero
maximum spread: 67, maximum offset: 209


****y.go******
// Code generated by goyacc -o ast/y.go ast/grammar.y. DO NOT EDIT.

//line ast/grammar.y:1

package ast

import __yyfmt__ "fmt"

//line ast/grammar.y:3

//line ast/grammar.y:43
type yySymType struct {
	yys                        int
	token                      Token
	stmt_if                    *IfStatement
	opt_elseif_list            []Statement
	opt_else                   []Statement
	stmt                       Statement
	stmt_loop                  *LoopStatement
	funcProc                   *FunctionOrProcedure
	body                       []Statement
	opt_body                   []Statement
	declarations_method_params []ParamStatement
	declarations_method_param  ParamStatement
	exprs                      []Statement
	opt_export                 *Token
	opt_directive              *Token
	explicit_variables         map[string]VarStatement
	global_variables           []GlobalVariables
	opt_explicit_variables     map[string]VarStatement
	identifiers                []Token
	goToLabel                  *GoToLabelStatement
	opt_goToLabel              *GoToLabelStatement
}

const Directive = 57346
const Identifier = 57347
const Procedure = 57348
const Var = 57349
const EndProcedure = 57350
const If = 57351
const Then = 57352
const ElseIf = 57353
const Else = 57354
const EndIf = 57355
const For = 57356
const Each = 57357
const In = 57358
const To = 57359
const Loop = 57360
const EndLoop = 57361
const Break = 57362
const Not = 57363
const ValueParam = 57364
const While = 57365
const GoToLabel = 57366
const Continue = 57367
const Try = 57368
const Catch = 57369
const EndTry = 57370
const Number = 57371
const String = 57372
const New = 57373
const Function = 57374
const EndFunction = 57375
const Return = 57376
const Throw = 57377
const NeEq = 57378
const Le = 57379
const Ge = 57380
const Or = 57381
const And = 57382
const True = 57383
const False = 57384
const Undefind = 57385
const Export = 57386
const Date = 57387
const GoTo = 57388
const Execute = 57389
const BuiltinFunction = 57390
const UNARMinus = 57391
const UNARYPlus = 57392

var yyToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"':'",
	"';'",
	"Directive",
	"Identifier",
	"Procedure",
	"Var",
	"EndProcedure",
	"If",
	"Then",
	"ElseIf",
	"Else",
	"EndIf",
	"For",
	"Each",
	"In",
	"To",
	"Loop",
	"EndLoop",
	"Break",
	"Not",
	"ValueParam",
	"While",
	"GoToLabel",
	"Continue",
	"Try",
	"Catch",
	"EndTry",
	"Number",
	"String",
	"New",
	"Function",
	"EndFunction",
	"Return",
	"Throw",
	"NeEq",
	"Le",
	"Ge",
	"Or",
	"And",
	"True",
	"False",
	"Undefind",
	"Export",
	"Date",
	"GoTo",
	"Execute",
	"BuiltinFunction",
	"'='",
	"'>'",
	"'<'",
	"'+'",
	"'-'",
	"'*'",
	"'/'",
	"'%'",
	"UNARMinus",
	"UNARYPlus",
	"'('",
	"')'",
	"'?'",
	"'['",
	"']'",
	"','",
	"'.'",
}

var yyStatenames = [...]string{}

const yyEofCode = 1
const yyErrCode = 2
const yyInitialStackSize = 16

//line ast/grammar.y:380

//line yacctab:1
var yyExca = [...]int8{
	-1, 0,
	4, 15,
	5, 15,
	-2, 7,
	-1, 1,
	1, -1,
	-2, 0,
	-1, 2,
	1, 1,
	-2, 16,
	-1, 3,
	8, 7,
	9, 7,
	34, 7,
	-2, 15,
}

const yyPrivate = 57344

const yyLast = 628

var yyAct = [...]uint8{
	143, 7, 5, 117, 50, 197, 46, 149, 135, 20,
	160, 17, 124, 161, 36, 68, 70, 41, 52, 180,
	71, 72, 85, 138, 74, 76, 77, 69, 78, 88,
	123, 82, 83, 64, 65, 66, 62, 63, 176, 165,
	148, 146, 138, 138, 138, 138, 61, 59, 60, 54,
	55, 56, 57, 58, 137, 186, 98, 99, 100, 101,
	102, 103, 104, 105, 106, 107, 108, 109, 110, 142,
	66, 86, 140, 138, 138, 94, 139, 43, 122, 138,
	95, 61, 59, 60, 54, 55, 56, 57, 58, 70,
	125, 126, 70, 90, 128, 65, 66, 70, 89, 4,
	93, 43, 121, 38, 56, 57, 58, 61, 59, 60,
	54, 55, 56, 57, 58, 130, 132, 178, 136, 44,
	45, 127, 137, 38, 70, 87, 129, 145, 40, 92,
	171, 154, 53, 52, 81, 79, 156, 157, 162, 131,
	158, 153, 182, 44, 45, 70, 152, 167, 169, 97,
	118, 164, 170, 141, 205, 163, 166, 199, 53, 52,
	80, 177, 179, 211, 172, 177, 53, 52, 181, 53,
	52, 159, 183, 120, 119, 150, 187, 113, 52, 64,
	65, 66, 134, 192, 175, 188, 202, 193, 194, 191,
	190, 189, 61, 59, 60, 54, 55, 56, 57, 58,
	204, 201, 203, 206, 53, 52, 207, 136, 35, 209,
	136, 210, 39, 43, 212, 53, 52, 22, 53, 52,
	84, 195, 23, 54, 55, 56, 57, 58, 12, 19,
	73, 24, 40, 11, 25, 174, 133, 28, 27, 38,
	116, 173, 14, 13, 53, 52, 53, 52, 185, 31,
	32, 34, 208, 33, 21, 44, 45, 196, 6, 43,
	30, 29, 47, 22, 48, 2, 3, 18, 23, 42,
	1, 15, 51, 49, 12, 19, 10, 24, 40, 11,
	25, 198, 37, 28, 27, 38, 151, 91, 14, 13,
	26, 67, 96, 43, 168, 31, 32, 34, 8, 33,
	21, 44, 45, 75, 16, 9, 30, 29, 0, 19,
	0, 0, 40, 18, 0, 42, 0, 28, 27, 38,
	0, 0, 0, 0, 0, 0, 43, 0, 0, 31,
	32, 34, 0, 33, 21, 44, 45, 0, 0, 0,
	30, 29, 19, 0, 0, 40, 0, 18, 0, 42,
	28, 27, 38, 61, 59, 60, 54, 55, 56, 57,
	58, 0, 31, 32, 34, 0, 33, 21, 44, 45,
	0, 0, 0, 30, 29, 64, 65, 66, 62, 63,
	18, 0, 42, 0, 0, 0, 0, 0, 61, 59,
	60, 54, 55, 56, 57, 58, 64, 65, 66, 62,
	63, 0, 0, 138, 0, 0, 0, 0, 0, 61,
	59, 60, 54, 55, 56, 57, 58, 64, 65, 66,
	62, 63, 0, 144, 43, 0, 0, 0, 0, 0,
	61, 59, 60, 54, 55, 56, 57, 58, 64, 65,
	66, 200, 63, 40, 0, 0, 0, 0, 28, 27,
	0, 61, 59, 60, 54, 55, 56, 57, 58, 0,
	31, 32, 34, 0, 33, 0, 44, 45, 0, 0,
	0, 30, 29, 64, 65, 66, 62, 63, 0, 0,
	42, 0, 0, 0, 0, 0, 61, 59, 60, 54,
	55, 56, 57, 58, 0, 0, 0, 147, 64, 65,
	66, 62, 63, 184, 0, 0, 0, 0, 0, 0,
	0, 61, 59, 60, 54, 55, 56, 57, 58, 155,
	0, 0, 111, 0, 0, 0, 0, 0, 0, 64,
	65, 66, 62, 63, 0, 0, 0, 64, 65, 66,
	62, 63, 61, 59, 60, 54, 55, 56, 57, 58,
	61, 59, 60, 54, 55, 56, 57, 58, 115, 0,
	0, 0, 0, 0, 0, 114, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 64, 65, 66, 62,
	63, 112, 0, 0, 64, 65, 66, 62, 63, 61,
	59, 60, 54, 55, 56, 57, 58, 61, 59, 60,
	54, 55, 56, 57, 58, 0, 0, 64, 65, 66,
	62, 63, 0, 0, 0, 0, 0, 0, 0, 0,
	61, 59, 60, 54, 55, 56, 57, 58,
}

var yyPact = [...]int16{
	206, -1000, -1000, 206, -1000, 240, -1000, -5, -1000, -1000,
	-1000, -1000, -1000, 319, 319, -1000, -1000, -1000, 319, 319,
	-1000, 102, 319, 286, 319, 252, 126, -1000, -1000, 319,
	319, -1000, -1000, -1000, -1000, -1000, -45, -1000, 64, -1000,
	-1000, -35, 37, 32, 68, 19, 240, -1000, -1000, 252,
	-1000, -1000, -1000, -1000, 319, 319, 319, 319, 319, 319,
	319, 319, 319, 319, 319, 319, 319, -1000, -5, -1000,
	-5, 460, 302, -1000, 569, 170, 546, 538, 211, 143,
	167, 166, -1000, -1000, 94, -1000, 17, 319, 319, 319,
	319, -1000, 319, -1000, -1000, 319, -1000, -1000, 48, 48,
	-1000, -1000, -1000, 169, 169, 302, 400, 141, 56, 30,
	302, -1000, 252, 121, 319, -1000, -1000, 8, -1000, 15,
	11, -35, 319, 7, -1000, 358, 337, -21, 435, -22,
	162, 70, 499, 252, 252, 173, 164, -1000, -1000, 131,
	131, -23, -1000, 319, -1000, 319, -1000, -1000, -1000, 134,
	319, 110, -45, -1000, 90, -1000, 214, 154, -1000, -1000,
	-24, 66, -1000, 155, -43, -1000, -1000, 337, 127, 252,
	491, -1000, -7, 252, -1000, -1000, 76, 131, 417, -1000,
	76, 319, -1000, 240, 252, 252, -1000, 200, -1000, 66,
	-1000, 148, 379, 162, 165, -1000, 148, 252, 145, 143,
	-1000, -1000, -1000, 252, 242, 143, 13, 128, -1000, 13,
	-1000, -1000, -1000,
}

var yyPgo = [...]int16{
	0, 264, 2, 99, 305, 304, 298, 7, 294, 292,
	291, 30, 1, 8, 290, 11, 10, 13, 12, 287,
	14, 286, 9, 282, 5, 281, 3, 276, 17, 208,
	273, 4, 272, 271, 270, 266, 258, 257, 0, 248,
	241, 236, 220, 182,
}

var yyR1 = [...]int8{
	0, 34, 34, 35, 35, 36, 36, 14, 14, 13,
	13, 33, 37, 5, 5, 2, 2, 1, 1, 9,
	9, 30, 30, 24, 24, 25, 25, 6, 7, 7,
	8, 8, 23, 39, 4, 40, 4, 41, 4, 21,
	21, 21, 3, 3, 3, 3, 3, 3, 3, 3,
	10, 10, 20, 20, 28, 28, 28, 28, 28, 28,
	19, 19, 43, 27, 12, 12, 12, 12, 12, 12,
	12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
	12, 12, 18, 18, 17, 17, 17, 16, 16, 16,
	22, 22, 22, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 29, 11, 11, 26, 26, 31,
	32, 38, 42,
}

var yyR2 = [...]int8{
	0, 1, 2, 1, 2, 1, 1, 0, 1, 0,
	1, 5, 0, 11, 10, 0, 1, 1, 3, 0,
	1, 1, 1, 0, 1, 3, 4, 7, 0, 5,
	0, 2, 8, 0, 9, 0, 8, 0, 6, 1,
	1, 3, 1, 1, 1, 1, 1, 1, 2, 2,
	0, 1, 1, 3, 1, 4, 4, 2, 4, 4,
	1, 1, 0, 6, 1, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 2,
	1, 2, 0, 1, 1, 2, 3, 0, 1, 3,
	2, 5, 4, 1, 1, 2, 2, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 3, 1, 3, 1,
	1, 1, 1,
}

var yyChk = [...]int16{
	-1000, -34, -1, -35, -3, -2, -36, -12, -6, -4,
	-27, 27, 22, 37, 36, -33, -5, -15, 61, 23,
	-22, 48, 11, 16, 25, 28, -14, 32, 31, 55,
	54, 43, 44, 47, 45, -29, -20, -23, 33, 6,
	26, -28, 63, 7, 49, 50, -2, -36, -1, -30,
	-31, -32, 5, 4, 54, 55, 56, 57, 58, 52,
	53, 51, 41, 42, 38, 39, 40, -10, -12, -18,
	-12, -12, -12, -29, -12, 17, -12, -12, -2, 9,
	34, 8, -12, -12, -42, 67, 7, 61, 64, 61,
	61, -19, 61, 32, 7, 61, -9, -3, -12, -12,
	-12, -12, -12, -12, -12, -12, -12, -12, -12, -12,
	-12, 62, 12, 7, 19, 20, 29, -26, 7, 7,
	7, -28, 61, -11, -18, -12, -12, -11, -12, -11,
	-2, 18, -12, -41, -43, -13, -38, 46, 66, 61,
	61, -11, 62, -38, 65, -38, 62, 62, 62, -7,
	13, -21, -20, -22, 61, 20, -2, -2, -31, 7,
	-16, -17, 7, 24, -16, 62, -18, -12, -8, 14,
	-12, 20, -22, -40, 21, 30, 62, -38, 51, 7,
	62, -38, 15, -2, 12, -39, 62, -2, -13, -17,
	-15, -13, -12, -2, -2, 21, -37, -24, -25, 9,
	62, -7, 21, -24, -2, 9, -26, -2, 10, -26,
	-31, 35, -31,
}

var yyDef = [...]int8{
	-2, -2, -2, -2, 17, 0, 3, 42, 43, 44,
	45, 46, 47, 50, 82, 5, 6, 64, 0, 0,
	80, 0, 0, 0, 0, 15, 0, 93, 94, 0,
	0, 97, 98, 99, 100, 101, 102, 103, 0, 8,
	104, 52, 0, 54, 0, 0, 2, 4, 16, 19,
	21, 22, 109, 110, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 48, 51, 49,
	83, 0, 79, 81, 0, 0, 0, 0, 0, 0,
	0, 0, 95, 96, 0, 112, 90, 82, 0, 0,
	82, 57, 0, 60, 61, 82, 18, 20, 66, 67,
	68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
	78, 65, 15, 0, 0, 37, 62, 9, 107, 0,
	0, 53, 82, 0, 105, 0, 0, 0, 0, 0,
	28, 0, 0, 15, 15, 0, 0, 10, 111, 87,
	87, 0, 92, 82, 56, 0, 55, 58, 59, 30,
	0, 0, 39, 40, 0, 35, 0, 0, 11, 108,
	0, 88, 84, 0, 0, 91, 106, 0, 0, 15,
	0, 33, 0, 15, 38, 63, 9, 0, 0, 85,
	9, 0, 27, 31, 15, 15, 41, 0, 12, 89,
	86, 23, 0, 28, 0, 36, 23, 15, 24, 0,
	32, 29, 34, 15, 0, 0, 0, 0, 14, 0,
	25, 13, 26,
}

var yyTok1 = [...]int8{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 58, 3, 3,
	61, 62, 56, 54, 66, 55, 67, 57, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 4, 5,
	53, 51, 52, 63, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 64, 3, 65,
}

var yyTok2 = [...]int8{
	2, 3, 6, 7, 8, 9, 10, 11, 12, 13,
	14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
	34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
	44, 45, 46, 47, 48, 49, 50, 59, 60,
}

var yyTok3 = [...]int8{
	0,
}

var yyErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	yyDebug        = 0
	yyErrorVerbose = false
)

type yyLexer interface {
	Lex(lval *yySymType) int
	Error(s string)
}

type yyParser interface {
	Parse(yyLexer) int
	Lookahead() int
}

type yyParserImpl struct {
	lval  yySymType
	stack [yyInitialStackSize]yySymType
	char  int
}

func (p *yyParserImpl) Lookahead() int {
	return p.char
}

func yyNewParser() yyParser {
	return &yyParserImpl{}
}

const yyFlag = -1000

func yyTokname(c int) string {
	if c >= 1 && c-1 < len(yyToknames) {
		if yyToknames[c-1] != "" {
			return yyToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func yyStatname(s int) string {
	if s >= 0 && s < len(yyStatenames) {
		if yyStatenames[s] != "" {
			return yyStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func yyErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !yyErrorVerbose {
		return "syntax error"
	}

	for _, e := range yyErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + yyTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(yyPact[state])
	for tok := TOKSTART; tok-1 < len(yyToknames); tok++ {
		if n := base + tok; n >= 0 && n < yyLast && int(yyChk[int(yyAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if yyDef[state] == -2 {
		i := 0
		for yyExca[i] != -1 || int(yyExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; yyExca[i] >= 0; i += 2 {
			tok := int(yyExca[i])
			if tok < TOKSTART || yyExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if yyExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += yyTokname(tok)
	}
	return res
}

func yylex1(lex yyLexer, lval *yySymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(yyTok1[0])
		goto out
	}
	if char < len(yyTok1) {
		token = int(yyTok1[char])
		goto out
	}
	if char >= yyPrivate {
		if char < yyPrivate+len(yyTok2) {
			token = int(yyTok2[char-yyPrivate])
			goto out
		}
	}
	for i := 0; i < len(yyTok3); i += 2 {
		token = int(yyTok3[i+0])
		if token == char {
			token = int(yyTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(yyTok2[1]) /* unknown char */
	}
	if yyDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(token), uint(char))
	}
	return char, token
}

func yyParse(yylex yyLexer) int {
	return yyNewParser().Parse(yylex)
}

func (yyrcvr *yyParserImpl) Parse(yylex yyLexer) int {
	var yyn int
	var yyVAL yySymType
	var yyDollar []yySymType
	_ = yyDollar // silence set and not used
	yyS := yyrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	yystate := 0
	yyrcvr.char = -1
	yytoken := -1 // yyrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		yystate = -1
		yyrcvr.char = -1
		yytoken = -1
	}()
	yyp := -1
	goto yystack

ret0:
	return 0

ret1:
	return 1

yystack:
	/* put a state and value onto the stack */
	if yyDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", yyTokname(yytoken), yyStatname(yystate))
	}

	yyp++
	if yyp >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyS[yyp] = yyVAL
	yyS[yyp].yys = yystate

yynewstate:
	yyn = int(yyPact[yystate])
	if yyn <= yyFlag {
		goto yydefault /* simple state */
	}
	if yyrcvr.char < 0 {
		yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
	}
	yyn += yytoken
	if yyn < 0 || yyn >= yyLast {
		goto yydefault
	}
	yyn = int(yyAct[yyn])
	if int(yyChk[yyn]) == yytoken { /* valid shift */
		yyrcvr.char = -1
		yytoken = -1
		yyVAL = yyrcvr.lval
		yystate = yyn
		if Errflag > 0 {
			Errflag--
		}
		goto yystack
	}

yydefault:
	/* default state action */
	yyn = int(yyDef[yystate])
	if yyn == -2 {
		if yyrcvr.char < 0 {
			yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if yyExca[xi+0] == -1 && int(yyExca[xi+1]) == yystate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			yyn = int(yyExca[xi+0])
			if yyn < 0 || yyn == yytoken {
				break
			}
		}
		yyn = int(yyExca[xi+1])
		if yyn < 0 {
			goto ret0
		}
	}
	if yyn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			yylex.Error(yyErrorMessage(yystate, yytoken))
			Nerrs++
			if yyDebug >= 1 {
				__yyfmt__.Printf("%s", yyStatname(yystate))
				__yyfmt__.Printf(" saw %s\n", yyTokname(yytoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for yyp >= 0 {
				yyn = int(yyPact[yyS[yyp].yys]) + yyErrCode
				if yyn >= 0 && yyn < yyLast {
					yystate = int(yyAct[yyn]) /* simulate a shift of "error" */
					if int(yyChk[yystate]) == yyErrCode {
						goto yystack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if yyDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
				}
				yyp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if yyDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yytoken))
			}
			if yytoken == yyEofCode {
				goto ret1
			}
			yyrcvr.char = -1
			yytoken = -1
			goto yynewstate /* try again in the same state */
		}
	}

	/* reduction by production yyn */
	if yyDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
	}

	yynt := yyn
	yypt := yyp
	_ = yypt // guard against "declared and not used"

	yyp -= int(yyR2[yyn])
	// yyp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if yyp+1 >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyVAL = yyS[yyp+1]

	/* consult goto table to find next state */
	yyn = int(yyR1[yyn])
	yyg := int(yyPgo[yyn])
	yyj := yyg + yyS[yyp].yys + 1

	if yyj >= yyLast {
		yystate = int(yyAct[yyg])
	} else {
		yystate = int(yyAct[yyj])
		if int(yyChk[yystate]) != -yyn {
			yystate = int(yyAct[yyg])
		}
	}
	// dummy call; replaced with literal code
	switch yynt {

	case 1:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:92
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[1].body, yylex)
			}
		}
	case 2:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:97
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[2].opt_body, yylex)
			}
		}
	case 5:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:107
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[1].global_variables, yylex)
			}
		}
	case 6:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:112
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[1].funcProc, yylex)
			}
		}
	case 7:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:119
		{
			yyVAL.opt_directive = nil
		}
	case 8:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:120
		{
			yyVAL.opt_directive = &yyDollar[1].token
		}
	case 9:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:123
		{
			yyVAL.opt_export = nil
		}
	case 10:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:124
		{
			yyVAL.opt_export = &yyDollar[1].token
		}
	case 11:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:127
		{
			yyVAL.global_variables = make([]GlobalVariables, len(yyDollar[3].identifiers), len(yyDollar[3].identifiers))
			for i, v := range yyDollar[3].identifiers {
				if yyDollar[1].opt_directive != nil {
					yyVAL.global_variables[i].Directive = yyDollar[1].opt_directive.literal
				}

				yyVAL.global_variables[i].Export = yyDollar[4].opt_export != nil
				yyVAL.global_variables[i].Var = VarStatement{Name: v.literal}
			}
		}
	case 12:
		yyDollar = yyS[yypt-7 : yypt+1]
//line ast/grammar.y:140
		{
			isFunction(true, yylex)
		}
	case 13:
		yyDollar = yyS[yypt-11 : yypt+1]
//line ast/grammar.y:141
		{
			yyVAL.funcProc = createFunctionOrProcedure(PFTypeFunction, yyDollar[1].opt_directive, yyDollar[3].token.literal, yyDollar[5].declarations_method_params, yyDollar[7].opt_export, yyDollar[9].opt_explicit_variables, yyDollar[10].opt_body)
			isFunction(false, yylex)
		}
	case 14:
		yyDollar = yyS[yypt-10 : yypt+1]
//line ast/grammar.y:146
		{
			yyVAL.funcProc = createFunctionOrProcedure(PFTypeProcedure, yyDollar[1].opt_directive, yyDollar[3].token.literal, yyDollar[5].declarations_method_params, yyDollar[7].opt_export, yyDollar[8].opt_explicit_variables, yyDollar[9].opt_body)
		}
	case 15:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:151
		{
			yyVAL.opt_body = nil
		}
	case 16:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:152
		{
			yyVAL.opt_body = yyDollar[1].body
		}
	case 17:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:156
		{
			yyVAL.body = []Statement{yyDollar[1].stmt}
		}
	case 18:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:157
		{
			if yyDollar[2].token.literal == ":" && len(yyDollar[1].opt_body) > 0 {
				if _, ok := yyDollar[1].opt_body[len(yyDollar[1].opt_body)-1].(*GoToLabelStatement); !ok {
					yylex.Error("semicolon (;) is expected")
				}
			}
			if yyDollar[3].stmt != nil {
				yyVAL.body = append(yyVAL.body, yyDollar[3].stmt)
			}
		}
	case 19:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:170
		{
			yyVAL.stmt = nil
		}
	case 20:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:171
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 21:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:174
		{
			yyVAL.token = yyDollar[1].token
		}
	case 22:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:174
		{
			yyVAL.token = yyDollar[1].token
		}
	case 23:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:178
		{
			yyVAL.opt_explicit_variables = map[string]VarStatement{}
		}
	case 24:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:179
		{
			yyVAL.opt_explicit_variables = yyDollar[1].explicit_variables
		}
	case 25:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:182
		{
			if vars, err := appendVarStatements(map[string]VarStatement{}, yyDollar[2].identifiers); err != nil {
				yylex.Error(err.Error())
			} else {
				yyVAL.explicit_variables = vars
			}
		}
	case 26:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:189
		{
			if vars, err := appendVarStatements(yyDollar[1].explicit_variables, yyDollar[3].identifiers); err != nil {
				yylex.Error(err.Error())
			} else {
				yyVAL.explicit_variables = vars
			}
		}
	case 27:
		yyDollar = yyS[yypt-7 : yypt+1]
//line ast/grammar.y:200
		{
			yyVAL.stmt_if = &IfStatement{
				Expression:  yyDollar[2].stmt,
				TrueBlock:   yyDollar[4].opt_body,
				IfElseBlock: yyDollar[5].opt_elseif_list,
				ElseBlock:   yyDollar[6].opt_else,
			}
		}
	case 28:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:210
		{
			yyVAL.opt_elseif_list = []Statement{}
		}
	case 29:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:211
		{
			yyVAL.opt_elseif_list = append(yyDollar[5].opt_elseif_list, &IfStatement{
				Expression: yyDollar[2].stmt,
				TrueBlock:  yyDollar[4].opt_body,
			})
		}
	case 30:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:219
		{
			yyVAL.opt_else = nil
		}
	case 31:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:220
		{
			yyVAL.opt_else = yyDollar[2].opt_body
		}
	case 32:
		yyDollar = yyS[yypt-8 : yypt+1]
//line ast/grammar.y:223
		{
			yyVAL.stmt = TernaryStatement{
				Expression: yyDollar[3].stmt,
				TrueBlock:  yyDollar[5].stmt,
				ElseBlock:  yyDollar[7].stmt,
			}
		}
	case 33:
		yyDollar = yyS[yypt-6 : yypt+1]
//line ast/grammar.y:232
		{
			setLoopFlag(true, yylex)
		}
	case 34:
		yyDollar = yyS[yypt-9 : yypt+1]
//line ast/grammar.y:232
		{
			yyVAL.stmt_loop = &LoopStatement{
				For:  yyDollar[3].token.literal,
				In:   yyDollar[5].stmt,
				Body: yyDollar[8].opt_body,
			}
			setLoopFlag(false, yylex)
		}
	case 35:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:240
		{
			setLoopFlag(true, yylex)
		}
	case 36:
		yyDollar = yyS[yypt-8 : yypt+1]
//line ast/grammar.y:240
		{
			yyVAL.stmt_loop = &LoopStatement{
				For:  yyDollar[2].stmt,
				To:   yyDollar[4].stmt,
				Body: yyDollar[7].opt_body,
			}
			setLoopFlag(false, yylex)
		}
	case 37:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:248
		{
			setLoopFlag(true, yylex)
		}
	case 38:
		yyDollar = yyS[yypt-6 : yypt+1]
//line ast/grammar.y:248
		{
			yyVAL.stmt_loop = &LoopStatement{
				WhileExpr: yyDollar[2].stmt,
				Body:      yyDollar[5].opt_body,
			}
		}
	case 39:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:257
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 40:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:258
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 41:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:259
		{
			yyVAL.stmt = yyDollar[2].stmt
		}
	case 42:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:262
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 43:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:263
		{
			yyVAL.stmt = yyDollar[1].stmt_if
		}
	case 44:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:264
		{
			yyVAL.stmt = yyDollar[1].stmt_loop
		}
	case 45:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:265
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 46:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:266
		{
			yyVAL.stmt = ContinueStatement{}
			checkLoopOperator(yyDollar[1].token, yylex)
		}
	case 47:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:267
		{
			yyVAL.stmt = BreakStatement{}
			checkLoopOperator(yyDollar[1].token, yylex)
		}
	case 48:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:268
		{
			yyVAL.stmt = ThrowStatement{Param: yyDollar[2].stmt}
			checkThrowParam(yyDollar[1].token, yyDollar[2].stmt, yylex)
		}
	case 49:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:269
		{
			yyVAL.stmt = &ReturnStatement{Param: yyDollar[2].stmt}
			checkReturnParam(yyDollar[2].stmt, yylex)
		}
	case 50:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:272
		{
			yyVAL.stmt = nil
		}
	case 51:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:273
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 52:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:278
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 53:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:279
		{
			yyVAL.stmt = CallChainStatement{Unit: yyDollar[3].stmt, Call: yyDollar[1].stmt}
		}
	case 54:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:285
		{
			yyVAL.stmt = VarStatement{Name: yyDollar[1].token.literal}
		}
	case 55:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:286
		{
			yyVAL.stmt = MethodStatement{Name: yyDollar[1].token.literal, Param: yyDollar[3].exprs}
		}
	case 56:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:287
		{
			yyVAL.stmt = ItemStatement{Object: yyDollar[1].stmt, Item: yyDollar[3].stmt}
		}
	case 57:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:288
		{
			yyVAL.stmt = MethodStatement{Name: yyDollar[1].token.literal, Param: []Statement{yyDollar[2].stmt}}
		}
	case 58:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:289
		{
			yyVAL.stmt = MethodStatement{Name: yyDollar[1].token.literal, Param: []Statement{yyDollar[3].stmt}}
		}
	case 59:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:290
		{
			yyVAL.stmt = &BuiltinFunctionStatement{Name: yyDollar[1].token.literal, Param: yyDollar[3].exprs}
		}
	case 60:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:293
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 61:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:294
		{
			yyVAL.stmt = VarStatement{Name: yyDollar[1].token.literal}
		}
	case 62:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:297
		{
			setTryFlag(true, yylex)
		}
	case 63:
		yyDollar = yyS[yypt-6 : yypt+1]
//line ast/grammar.y:297
		{
			yyVAL.stmt = TryStatement{Body: yyDollar[2].opt_body, Catch: yyDollar[5].opt_body}
			setTryFlag(false, yylex)
		}
	case 64:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:303
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 65:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:304
		{
			yyVAL.stmt = yyDollar[2].stmt
		}
	case 66:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:305
		{
			yyVAL.stmt = &ExpStatement{Operation: OpPlus, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 67:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:306
		{
			yyVAL.stmt = &ExpStatement{Operation: OpMinus, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 68:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:307
		{
			yyVAL.stmt = &ExpStatement{Operation: OpMul, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 69:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:308
		{
			yyVAL.stmt = &ExpStatement{Operation: OpDiv, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 70:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:309
		{
			yyVAL.stmt = &ExpStatement{Operation: OpMod, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 71:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:310
		{
			yyVAL.stmt = &ExpStatement{Operation: OpGt, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 72:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:311
		{
			yyVAL.stmt = &ExpStatement{Operation: OpLt, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 73:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:312
		{
			yyVAL.stmt = &ExpStatement{Operation: OpEq, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 74:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:313
		{
			yyVAL.stmt = &ExpStatement{Operation: OpOr, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 75:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:314
		{
			yyVAL.stmt = &ExpStatement{Operation: OpAnd, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 76:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:315
		{
			yyVAL.stmt = &ExpStatement{Operation: OpNe, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 77:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:316
		{
			yyVAL.stmt = &ExpStatement{Operation: OpLe, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 78:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:317
		{
			yyVAL.stmt = &ExpStatement{Operation: OpGe, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 79:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:318
		{
			yyVAL.stmt = not(yyDollar[2].stmt)
		}
	case 80:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:319
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 81:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:320
		{
			yyVAL.stmt = GoToStatement{Label: yyDollar[2].goToLabel}
		}
	case 82:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:323
		{
			yyVAL.stmt = nil
		}
	case 83:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:323
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 84:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:326
		{
			yyVAL.declarations_method_param = *(&ParamStatement{}).Fill(nil, yyDollar[1].token)
		}
	case 85:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:327
		{
			yyVAL.declarations_method_param = *(&ParamStatement{}).Fill(&yyDollar[1].token, yyDollar[2].token)
		}
	case 86:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:328
		{
			yyVAL.declarations_method_param = *(yyVAL.declarations_method_param.DefaultValue(yyDollar[3].stmt))
		}
	case 87:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:331
		{
			yyVAL.declarations_method_params = []ParamStatement{}
		}
	case 88:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:332
		{
			yyVAL.declarations_method_params = []ParamStatement{yyDollar[1].declarations_method_param}
		}
	case 89:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:333
		{
			yyVAL.declarations_method_params = append(yyDollar[1].declarations_method_params, yyDollar[3].declarations_method_param)
		}
	case 90:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:341
		{
			yyVAL.stmt = NewObjectStatement{Constructor: yyDollar[2].token.literal}
		}
	case 91:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:342
		{
			yyVAL.stmt = NewObjectStatement{Constructor: yyDollar[2].token.literal, Param: yyDollar[4].exprs}
		}
	case 92:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:343
		{
			yyVAL.stmt = NewObjectStatement{Param: yyDollar[3].exprs}
		}
	case 93:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:346
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 94:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:347
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 95:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:348
		{
			yyVAL.stmt = unaryMinus(yyDollar[2].stmt)
		}
	case 96:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:349
		{
			yyVAL.stmt = yyDollar[2].stmt
		}
	case 97:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:350
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 98:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:351
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 99:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:352
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 100:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:353
		{
			yyVAL.stmt = UndefinedStatement{}
		}
	case 101:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:354
		{
			yyVAL.stmt = yyDollar[1].goToLabel
		}
	case 102:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:355
		{
			if tok, ok := yyDollar[1].stmt.(Token); ok {
				yyVAL.stmt = tok.literal
			} else {
				yyVAL.stmt = yyDollar[1].stmt
			}
		}
	case 103:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:362
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 104:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:365
		{
			yyVAL.goToLabel = &GoToLabelStatement{Name: yyDollar[1].token.literal}
		}
	case 105:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:367
		{
			yyVAL.exprs = []Statement{yyDollar[1].stmt}
		}
	case 106:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:368
		{
			yyVAL.exprs = append(yyVAL.exprs, yyDollar[3].stmt)
		}
	case 107:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:371
		{
			yyVAL.identifiers = []Token{yyDollar[1].token}
		}
	case 108:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:372
		{
			yyVAL.identifiers = append(yyVAL.identifiers, yyDollar[3].token)
		}
	case 109:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:375
		{
			yyVAL.token = yyDollar[1].token
		}
	case 110:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:376
		{
			yyVAL.token = yyDollar[1].token
		}
	}
	goto yystack /* stack new state and value */
}



****tokens.go******
package ast

import (
	"fmt"
	"strconv"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"
)

//go:generate mockgen -source=$GOFILE -destination=./mock/mock.go
type Iast interface {
	SrsCode() string
}

type Position struct {
	Line   int
	Column int
}

type Token struct {
	ast      Iast
	value    interface{}
	literal  string
	position Position
	offset   int
	prevDot  bool
}

const (
	EOL      = '\n' // end of line.
	emptyLit = ""
)

var (
	tokens = map[string]int{
		"процедура":         Procedure,
		"перем":             Var,
		"перейти":           GoTo,
		"конецпроцедуры":    EndProcedure,
		"знач":              ValueParam,
		"если":              If,
		"тогда":             Then,
		"иначеесли":         ElseIf,
		"иначе":             Else,
		"конецесли":         EndIf,
		"для":               For,
		"каждого":           Each,
		"из":                In,
		"по":                To,
		"цикл":              Loop,
		"конеццикла":        EndLoop,
		"прервать":          Break,
		"продолжить":        Continue,
		"попытка":           Try,
		"новый":             New,
		"исключение":        Catch,
		"пока":              While,
		"конецпопытки":      EndTry,
		"функция":           Function,
		"конецфункции":      EndFunction,
		"возврат":           Return,
		"вызватьисключение": Throw,
		"и":                 And,
		"или":               Or,
		"истина":            True,
		"ложь":              False,
		"неопределено":      Undefind,
		"не":                Not,
		"экспорт":           Export,
		"выполнить":         Execute,
		"выполнитьобработкуоповещения": BuiltinFunction,
		//"вычислить":         Eval,
		// "массив":            Array,
		// "структура":         Struct,
		// "соответствие":      Dictionary,
	}

	directives = map[string]int{
		"&наклиенте":                      Directive,
		"&насервере":                      Directive,
		"&насерверебезконтекста":          Directive,
		"&наклиентенасерверебезконтекста": Directive,
		"&наклиентенасервере":             Directive,
	}
)

func (t *Token) Next(ast Iast) (token int, err error) {
	t.ast = ast
	token, t.literal, err = t.next()

	switch token {
	case Number:
		t.value, err = strconv.ParseFloat(t.literal, 64)
	case String:
		t.value = t.literal
	case Date:
		formats := []string{"20060102", "200601021504", "20060102150405"} // Допускается опускать либо время целиком, либо только секунды.
		for _, f := range formats {
			// если все 0 это равносильно пустой дате
			if strings.Count(t.literal, "0") == len(t.literal) {
				t.value = time.Time{}
				return
			}

			if t.value, err = time.Parse(f, t.literal); err == nil {
				break
			}
		}
	case Undefind:
		t.value = nil
	case True:
		t.value = true
	case False:
		t.value = false
	}

	return
}

func (t *Token) next() (int, string, error) {
	t.skipSpace()
	t.skipComment()
	t.skipRegions()

	if t.prevDot {
		defer func() { t.prevDot = false }()
	}

	switch let := t.currentLet(); {
	case isLetter(let):
		literal := t.scanIdentifier()
		lowLit := fastToLower(literal)

		if tName, ok := tokens[lowLit]; ok && !t.prevDot {
			return tName, literal, nil
		} else {
			return Identifier, literal, nil
		}
	case let == '.':
		// если после точки у нас следует идентификатор то нам нужно читать его обычным идентификатором
		// Могут быть таие случаи стр.Истина = 1 или стр.Функция = 2 (стр в данном случае какой-то объект, например структура)
		// нам нужно что бы то что следует после точки считалось Identifier, а не определенным зарезервированным токеном
		t.prevDot = true

		t.nextPos()
		return int(let), string(let), nil
	case isDigit(let):
		if literal, err := t.scanNumber(); err != nil {
			return EOF, emptyLit, err
		} else {
			return Number, literal, nil
		}

	case let == 0x27:
		literal, err := t.scanString(let)
		if err != nil {
			return EOF, emptyLit, err
		}

		// В литерале даты игнорируются все значения, отличные от цифр.
		if literal = extractDigits(literal); literal == "" {
			return EOF, emptyLit, fmt.Errorf("incorrect Date type constant")
		}

		return Date, literal, nil
	case let == '/' || let == ';' || let == '(' || let == ')' || let == ',' || let == '=' || let == '-' || let == '+' || let == '*' || let == '?' || let == '[' || let == ']' || let == ':' || let == '%':
		t.nextPos()
		return int(let), string(let), nil
	case let == '"':
		literal, err := t.scanString(let)
		if err != nil {
			return EOF, emptyLit, err
		}

		return String, literal, nil
	case let == '<':
		if t.nextLet() == '>' {
			t.nextPos()
			t.nextPos()
			return NeEq, "<>", nil
		} else if t.nextLet() == '=' {
			t.nextPos()
			t.nextPos()
			return Le, "<=", nil
		} else {
			t.nextPos()
			return int(let), string(let), nil
		}
	case let == '>':
		if t.nextLet() == '=' {
			t.nextPos()
			t.nextPos()
			return Ge, ">=", nil
		} else {
			t.nextPos()
			return int(let), string(let), nil
		}

	// case let == '#':
	// literal, err := t.scanIdentifier()
	// if err != nil {
	// 	return EOF, emptyLit, err
	// }

	case let == '&':
		t.nextPos()
		pos := t.offset

		literal := t.scanIdentifier()
		lowLit := fastToLower("&" + literal)

		if tName, ok := directives[lowLit]; ok {
			return tName, "&" + literal, nil
		} else {
			t.offset = pos
			return int(let), string(let), fmt.Errorf(`syntax error %q`, string(let))
		}
	case let == '~':
		t.nextPos()
		return GoToLabel, t.scanIdentifier(), nil
	default:
		switch let {
		case EOF:
			t.nextPos()
			return EOF, emptyLit, nil
		// case '\n':
		// 	t.nextPos()
		// 	return int(let), string(let), nil
		default:
			t.nextPos()
			return int(let), string(let), fmt.Errorf(`syntax error %q`, string(let))
		}
	}
}

func (t *Token) scanIdentifier() string {
	ret := make([]rune, 0, 10) // как правило встречаются короткие идентификаторы и лучше предаллоцировать, это сильный буст дает

	for {
		let := t.currentLet()
		if !isLetter(let) && !isDigit(let) {
			break
		}

		ret = append(ret, let)
		t.nextPos()
	}

	return string(ret)
}

func (t *Token) scanString(end rune) (string, error) {
	var ret []rune

eos:
	for {
		t.nextPos()

		switch cl := t.currentLet(); {
		case cl == EOL:
			t.nextPos()
			if cl = t.currentLet(); cl != '|' && !isSpace(cl) {
				return "", fmt.Errorf("unexpected EOL")
			}

			ret = append(append(ret, EOL), cl)
		case cl == EOF:
			return "", fmt.Errorf("unexpected EOF")
		case cl == end:
			// пропускаем двойные "
			if t.nextLet() == '"' {
				t.nextPos()
				ret = append(ret, '"', '"')
				continue
			}

			t.nextPos()
			break eos
		default:
			ret = append(ret, cl)
		}
	}

	return string(ret), nil
}

func (t *Token) skipSpace() {
	for isSpace(t.currentLet()) {
		t.nextPos()
	}
}

func (t *Token) skipComment() {
	if t.currentLet() == '/' && t.nextLet() == '/' {
		for ch := t.currentLet(); ch != EOL && ch != EOF; ch = t.currentLet() {
			t.nextPos()
		}
		t.skipSpace()
	} else {
		return
	}

	// проверяем что на новой строке нет комментария или новой области, если есть, рекурсия
	if cl := t.currentLet(); cl == '/' {
		t.skipComment()
	} else if cl := t.currentLet(); cl == '#' {
		t.skipRegions()
	}
}

func (t *Token) skipRegions() {
	// todo пока будут пропускаться и условия типа #Если Не ВебКлиент Тогда, потом надо будет доработать
	if t.currentLet() == '#' {
		for ch := t.currentLet(); ch != EOL && ch != EOF; ch = t.currentLet() {
			t.nextPos()
		}
		t.skipSpace()
	}

	// проверяем что на новой строке нет комментария или новой области, если есть, рекурсия
	if cl := t.currentLet(); cl == '/' {
		t.skipComment()
	} else if cl := t.currentLet(); cl == '#' {
		t.skipRegions()
	}
}

func (t *Token) nextLet() rune {
	srsCode := t.ast.SrsCode()
	_, size := utf8.DecodeRuneInString(srsCode[t.offset:])
	t.offset += size
	defer func() { t.offset -= size }()

	return t.currentLet()
}

func (t *Token) currentLet() rune {
	srsCode := t.ast.SrsCode()

	if t.offset >= len(srsCode) {
		return EOF
	}

	char, _ := utf8.DecodeRuneInString(srsCode[t.offset:])
	if char == utf8.RuneError {
		fmt.Println(fmt.Errorf("error decoding the character"))
		return char
	}

	return char
}

func (t *Token) GetPosition() Position {
	srsCode := t.ast.SrsCode()
	eol := strings.LastIndex(srsCode[:t.offset], "\n") + 1
	lineBegin := IF[int](eol < 0, 0, eol)

	return Position{
		Line:   strings.Count(srsCode[:t.offset], "\n") + 1,
		Column: len([]rune(srsCode[lineBegin:t.offset])) + 1,
	}
}

func (t *Token) nextPos() {
	srsCode := t.ast.SrsCode()
	_, size := utf8.DecodeRuneInString(srsCode[t.offset:])
	t.offset += size
}

func (t *Token) scanNumber() (string, error) {
	var ret []rune

	let := t.currentLet()
	for ; isDigit(let) || let == '.'; let = t.currentLet() {
		ret = append(ret, let)
		t.nextPos()
	}

	if isLetter(let) {
		return "", fmt.Errorf("identifier immediately follow the number")
	}

	return string(ret), nil
}

func isLetter(ch rune) bool {
	return unicode.IsLetter(ch) || ch == '_'
}

func isDigit(ch rune) bool {
	return '0' <= ch && ch <= '9'
}

func isSpace(ch rune) bool {
	return ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n'
}

func IF[T any](condition bool, a, b T) T {
	if condition {
		return a
	} else {
		return b
	}
}

func IsDigit(str string) bool {
	for _, c := range str {
		if c < '0' || c > '9' {
			return false
		}
	}
	return true
}

func extractDigits(str string) string {
	result := make([]rune, 0, len(str))
	for _, c := range str {
		if c >= '0' && c <= '9' {
			result = append(result, c)
		}
	}
	return string(result)
}

func fastToLower(s string) string {
	return strings.ToLower(s)
}


****ast.go******
package ast

//go:generate goyacc  .\grammar.y

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"sync/atomic"

	"github.com/pkg/errors"
)

type AstNode struct {
	err  error
	code string
	ModuleStatement
	currentToken Token
	isLoop       atomic.Int32
	isTry        atomic.Int32
	isFunction   bool
}

const EOF = -1 // end of file
var (
	errVariableAlreadyDefined = fmt.Errorf("variable has already been defined")
)

func NewAST(code string) *AstNode {
	//fmt.Println("NewAST", code)
	return &AstNode{
		code: code,
	}
}

func (ast *AstNode) Parse() error {
	if len(strings.TrimSpace(ast.code)) == 0 {
		return nil
	}

	yyParse(ast)
	if ast.err != nil {
		errors.Wrap(ast.err, "parse error")
	}
	return ast.err
}

func (ast *AstNode) JSON() ([]byte, error) {
	return json.Marshal(&ast.ModuleStatement)
}

func (ast *AstNode) Lex(lval *yySymType) int {
	if len(ast.code) == 0 {
		return EOF
	}

	token, err := lval.token.Next(ast)
	if err != nil {
		ast.err = errors.Wrap(err, "get token error")
	}
	if token == EOF {
		return EOF
	}

	ast.currentToken = lval.token
	return token
}

func (ast *AstNode) SrsCode() string {
	return ast.code
}

func (ast *AstNode) Error(s string) {
	pos := ast.currentToken.GetPosition()
	pos.Column -= len([]rune(ast.currentToken.literal)) + 1

	ast.err = fmt.Errorf("%s. line: %d, column: %d (unexpected literal: %q)", s, pos.Line, pos.Column, ast.currentToken.literal)
}

func checkLoopOperator(token Token, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if ast.isLoop.Load() == 0 {
			yylex.Error(fmt.Sprintf("operator %q can only be used inside a loop", token.literal))
		}
	}
}

func checkThrowParam(token Token, param Statement, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if ast.isTry.Load() == 0 && param == nil {
			yylex.Error(fmt.Sprintf("operator %q without arguments can only be used when handling an exception", token.literal))
		}
	}
}

func isFunction(isFunc bool, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		ast.isFunction = isFunc
	}
}

func checkReturnParam(param Statement, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if !ast.isFunction && param != nil {
			yylex.Error("procedure cannot return a value")
		}
	}
}

func setLoopFlag(flag bool, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if flag {
			ast.isLoop.Add(1)
		} else {
			ast.isLoop.Add(-1)
		}
	}
}

func setTryFlag(flag bool, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if flag {
			ast.isTry.Add(1)
		} else {
			ast.isTry.Add(-1)
		}
	}
}

func createFunctionOrProcedure(Type StatementType, directive Statement, name string, params []ParamStatement, export Statement, variables map[string]VarStatement, body []Statement) *FunctionOrProcedure {
	result := &FunctionOrProcedure{
		Type:              Type,
		Name:              name,
		Body:              body,
		Export:            export != nil && !reflect.ValueOf(export).IsNil(),
		Params:            params,
		ExplicitVariables: variables,
	}

	if tok, ok := directive.(*Token); ok && tok != nil {
		result.Directive = tok.literal
	}

	return result
}

func appendVarStatements(existingVariables map[string]VarStatement, newVariables []Token) (map[string]VarStatement, error) {
	for _, v := range newVariables {
		if _, ok := existingVariables[v.literal]; ok {
			return map[string]VarStatement{}, fmt.Errorf("%w: with the specified name %q", errVariableAlreadyDefined, v.literal)
		} else {
			existingVariables[v.literal] = VarStatement{Name: v.literal}
		}
	}
	return existingVariables, nil
}

func unaryMinus(iv interface{}) interface{} {
	switch v := iv.(type) {
	case int:
		return -v
	case int32:
		return -v
	case int64:
		return -v
	case float32:
		return -v
	case float64:
		return -v
	case IUnary:
		return v.UnaryMinus()
	default:
		return v
	}
}

func not(iv interface{}) interface{} {
	switch v := iv.(type) {
	case bool:
		return !v
	case INot:
		return v.Not()
	default:
		return v
	}
}

