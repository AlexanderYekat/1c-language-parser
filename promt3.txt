***********tokens.go***************
package ast

import (
	"fmt"
	"strconv"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"
)

//go:generate mockgen -source=$GOFILE -destination=./mock/mock.go
type Iast interface {
	SrsCode() string
}

type Position struct {
	Line   int
	Column int
}

type Token struct {
	ast      Iast
	value    interface{}
	literal  string
	position Position
	offset   int
	prevDot  bool
}

const (
	EOL      = '\n' // end of line.
	emptyLit = ""
)

var (
	tokens = map[string]int{
		"процедура":         Procedure,
		"перем":             Var,
		"перейти":           GoTo,
		"конецпроцедуры":    EndProcedure,
		"знач":              ValueParam,
		"если":              If,
		"тогда":             Then,
		"иначеесли":         ElseIf,
		"иначе":             Else,
		"конецесли":         EndIf,
		"для":               For,
		"каждого":           Each,
		"из":                In,
		"по":                To,
		"цикл":              Loop,
		"конеццикла":        EndLoop,
		"прервать":          Break,
		"продолжить":        Continue,
		"попытка":           Try,
		"новый":             New,
		"исключение":        Catch,
		"пока":              While,
		"конецпопытки":      EndTry,
		"функция":           Function,
		"конецфункции":      EndFunction,
		"возврат":           Return,
		"вызватьисключение": Throw,
		"и":                 And,
		"или":               Or,
		"истина":            True,
		"ложь":              False,
		"неопределено":      Undefind,
		"не":                Not,
		"экспорт":           Export,
		"выполнить":         Execute,
		"выполнитьобработкуоповещения": BuiltinFunction,
		//"вычислить":         Eval,
		// "массив":            Array,
		// "структура":         Struct,
		// "соответствие":      Dictionary,
	}

	directives = map[string]int{
		"&наклиенте":                      Directive,
		"&насервере":                      Directive,
		"&насерверебезконтекста":          Directive,
		"&наклиентенасерверебезконтекста": Directive,
		"&наклиентенасервере":             Directive,
	}
)

func (t *Token) Next(ast Iast) (token int, err error) {
	t.ast = ast
	token, t.literal, err = t.next()

	switch token {
	case Number:
		t.value, err = strconv.ParseFloat(t.literal, 64)
	case String:
		t.value = t.literal
	case Date:
		formats := []string{"20060102", "200601021504", "20060102150405"} // Допускается опускать либо время целиком, либо только секунды.
		for _, f := range formats {
			// если все 0 это равносильно пустой дате
			if strings.Count(t.literal, "0") == len(t.literal) {
				t.value = time.Time{}
				return
			}

			if t.value, err = time.Parse(f, t.literal); err == nil {
				break
			}
		}
	case Undefind:
		t.value = nil
	case True:
		t.value = true
	case False:
		t.value = false
	}

	return
}

func (t *Token) next() (int, string, error) {
	t.skipSpace()
	t.skipComment()
	t.skipRegions()

	if t.prevDot {
		defer func() { t.prevDot = false }()
	}

	switch let := t.currentLet(); {
	case isLetter(let):
		literal := t.scanIdentifier()
		lowLit := fastToLower(literal)

		fmt.Println("lowLit", lowLit)
		if tName, ok := tokens[lowLit]; ok && !t.prevDot {
			fmt.Println("tName", tName)
			return tName, literal, nil
		} else {
			fmt.Println("Identifier", literal)
			return Identifier, literal, nil
		}
	case let == '.':
		// если после точки у нас следует идентификатор то нам нужно читать его обычным идентификатором
		// Могут быть таие случаи стр.Истина = 1 или стр.Функция = 2 (стр в данном случае какой-то объект, например структура)
		// нам нужно что бы то что следует после точки считалось Identifier, а не определенным зарезервированным токеном
		t.prevDot = true

		t.nextPos()
		return int(let), string(let), nil
	case isDigit(let):
		if literal, err := t.scanNumber(); err != nil {
			return EOF, emptyLit, err
		} else {
			return Number, literal, nil
		}

	case let == 0x27:
		literal, err := t.scanString(let)
		if err != nil {
			return EOF, emptyLit, err
		}

		// В литерале даты игнорируются все значения, отличные от цифр.
		if literal = extractDigits(literal); literal == "" {
			return EOF, emptyLit, fmt.Errorf("incorrect Date type constant")
		}

		return Date, literal, nil
	case let == '/' || let == ';' || let == '(' || let == ')' || let == ',' || let == '=' || let == '-' || let == '+' || let == '*' || let == '?' || let == '[' || let == ']' || let == ':' || let == '%':
		t.nextPos()
		return int(let), string(let), nil
	case let == '"':
		literal, err := t.scanString(let)
		if err != nil {
			return EOF, emptyLit, err
		}

		return String, literal, nil
	case let == '<':
		if t.nextLet() == '>' {
			t.nextPos()
			t.nextPos()
			return NeEq, "<>", nil
		} else if t.nextLet() == '=' {
			t.nextPos()
			t.nextPos()
			return Le, "<=", nil
		} else {
			t.nextPos()
			return int(let), string(let), nil
		}
	case let == '>':
		if t.nextLet() == '=' {
			t.nextPos()
			t.nextPos()
			return Ge, ">=", nil
		} else {
			t.nextPos()
			return int(let), string(let), nil
		}

	// case let == '#':
	// literal, err := t.scanIdentifier()
	// if err != nil {
	// 	return EOF, emptyLit, err
	// }

	case let == '&':
		t.nextPos()
		pos := t.offset

		literal := t.scanIdentifier()
		lowLit := fastToLower("&" + literal)

		if tName, ok := directives[lowLit]; ok {
			return tName, "&" + literal, nil
		} else {
			t.offset = pos
			return int(let), string(let), fmt.Errorf(`syntax error %q`, string(let))
		}
	case let == '~':
		t.nextPos()
		return GoToLabel, t.scanIdentifier(), nil
	default:
		switch let {
		case EOF:
			t.nextPos()
			return EOF, emptyLit, nil
		// case '\n':
		// 	t.nextPos()
		// 	return int(let), string(let), nil
		default:
			t.nextPos()
			return int(let), string(let), fmt.Errorf(`syntax error %q`, string(let))
		}
	}
}

func (t *Token) scanIdentifier() string {
	ret := make([]rune, 0, 10) // как правило встречаются короткие идентификаторы и лучше предаллоцировать, это сильный буст дает

	for {
		let := t.currentLet()
		if !isLetter(let) && !isDigit(let) {
			break
		}

		ret = append(ret, let)
		t.nextPos()
	}

	return string(ret)
}

func (t *Token) scanString(end rune) (string, error) {
	var ret []rune

eos:
	for {
		t.nextPos()

		switch cl := t.currentLet(); {
		case cl == EOL:
			t.nextPos()
			if cl = t.currentLet(); cl != '|' && !isSpace(cl) {
				return "", fmt.Errorf("unexpected EOL")
			}

			ret = append(append(ret, EOL), cl)
		case cl == EOF:
			return "", fmt.Errorf("unexpected EOF")
		case cl == end:
			// пропускаем двойные "
			if t.nextLet() == '"' {
				t.nextPos()
				ret = append(ret, '"', '"')
				continue
			}

			t.nextPos()
			break eos
		default:
			ret = append(ret, cl)
		}
	}

	return string(ret), nil
}

func (t *Token) skipSpace() {
	for isSpace(t.currentLet()) {
		t.nextPos()
	}
}

func (t *Token) skipComment() {
	if t.currentLet() == '/' && t.nextLet() == '/' {
		for ch := t.currentLet(); ch != EOL && ch != EOF; ch = t.currentLet() {
			t.nextPos()
		}
		t.skipSpace()
	} else {
		return
	}

	// проверяем что на новой строке нет комментария или новой области, если есть, рекурсия
	if cl := t.currentLet(); cl == '/' {
		t.skipComment()
	} else if cl := t.currentLet(); cl == '#' {
		t.skipRegions()
	}
}

func (t *Token) skipRegions() {
	// todo пока будут пропускаться и условия типа #Если Не ВебКлиент Тогда, потом надо будет доработать
	if t.currentLet() == '#' {
		for ch := t.currentLet(); ch != EOL && ch != EOF; ch = t.currentLet() {
			t.nextPos()
		}
		t.skipSpace()
	}

	// проверяем что на новой строке нет комментария или новой области, если есть, рекурсия
	if cl := t.currentLet(); cl == '/' {
		t.skipComment()
	} else if cl := t.currentLet(); cl == '#' {
		t.skipRegions()
	}
}

func (t *Token) nextLet() rune {
	srsCode := t.ast.SrsCode()
	_, size := utf8.DecodeRuneInString(srsCode[t.offset:])
	t.offset += size
	defer func() { t.offset -= size }()

	return t.currentLet()
}

func (t *Token) currentLet() rune {
	srsCode := t.ast.SrsCode()

	if t.offset >= len(srsCode) {
		return EOF
	}

	char, _ := utf8.DecodeRuneInString(srsCode[t.offset:])
	if char == utf8.RuneError {
		fmt.Println(fmt.Errorf("error decoding the character"))
		return char
	}

	return char
}

func (t *Token) GetPosition() Position {
	srsCode := t.ast.SrsCode()
	eol := strings.LastIndex(srsCode[:t.offset], "\n") + 1
	lineBegin := IF[int](eol < 0, 0, eol)

	return Position{
		Line:   strings.Count(srsCode[:t.offset], "\n") + 1,
		Column: len([]rune(srsCode[lineBegin:t.offset])) + 1,
	}
}

func (t *Token) nextPos() {
	srsCode := t.ast.SrsCode()
	_, size := utf8.DecodeRuneInString(srsCode[t.offset:])
	t.offset += size
}

func (t *Token) scanNumber() (string, error) {
	var ret []rune

	let := t.currentLet()
	for ; isDigit(let) || let == '.'; let = t.currentLet() {
		ret = append(ret, let)
		t.nextPos()
	}

	if isLetter(let) {
		return "", fmt.Errorf("identifier immediately follow the number")
	}

	return string(ret), nil
}

func isLetter(ch rune) bool {
	return unicode.IsLetter(ch) || ch == '_'
}

func isDigit(ch rune) bool {
	return '0' <= ch && ch <= '9'
}

func isSpace(ch rune) bool {
	return ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n'
}

func IF[T any](condition bool, a, b T) T {
	if condition {
		return a
	} else {
		return b
	}
}

func IsDigit(str string) bool {
	for _, c := range str {
		if c < '0' || c > '9' {
			return false
		}
	}
	return true
}

func extractDigits(str string) string {
	result := make([]rune, 0, len(str))
	for _, c := range str {
		if c >= '0' && c <= '9' {
			result = append(result, c)
		}
	}
	return string(result)
}

func fastToLower(s string) string {
	return strings.ToLower(s)
}



***********ast.go***************
package ast

//go:generate goyacc  .\grammar.y

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"sync/atomic"

	"github.com/pkg/errors"
)

type AstNode struct {
	err  error
	code string
	ModuleStatement
	currentToken Token
	isLoop       atomic.Int32
	isTry        atomic.Int32
	isFunction   bool
}

const EOF = -1 // end of file
var (
	errVariableAlreadyDefined = fmt.Errorf("variable has already been defined")
)

func NewAST(code string) *AstNode {
	//fmt.Println("NewAST", code)
	return &AstNode{
		code: code,
	}
}

func (ast *AstNode) Parse() error {
	if len(strings.TrimSpace(ast.code)) == 0 {
		return nil
	}

	yyParse(ast)
	if ast.err != nil {
		errors.Wrap(ast.err, "parse error")
	}
	return ast.err
}

func (ast *AstNode) JSON() ([]byte, error) {
	return json.Marshal(&ast.ModuleStatement)
}

func (ast *AstNode) Lex(lval *yySymType) int {
	if len(ast.code) == 0 {
		return EOF
	}

	token, err := lval.token.Next(ast)
	if err != nil {
		ast.err = errors.Wrap(err, "get token error")
	}
	if token == EOF {
		return EOF
	}

	ast.currentToken = lval.token
	return token
}

func (ast *AstNode) SrsCode() string {
	return ast.code
}

func (ast *AstNode) Error(s string) {
	pos := ast.currentToken.GetPosition()
	pos.Column -= len([]rune(ast.currentToken.literal)) + 1

	ast.err = fmt.Errorf("%s. line: %d, column: %d (unexpected literal: %q)", s, pos.Line, pos.Column, ast.currentToken.literal)
}

func checkLoopOperator(token Token, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if ast.isLoop.Load() == 0 {
			yylex.Error(fmt.Sprintf("operator %q can only be used inside a loop", token.literal))
		}
	}
}

func checkThrowParam(token Token, param Statement, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if ast.isTry.Load() == 0 && param == nil {
			yylex.Error(fmt.Sprintf("operator %q without arguments can only be used when handling an exception", token.literal))
		}
	}
}

func isFunction(isFunc bool, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		ast.isFunction = isFunc
	}
}

func checkReturnParam(param Statement, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if !ast.isFunction && param != nil {
			yylex.Error("procedure cannot return a value")
		}
	}
}

func setLoopFlag(flag bool, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if flag {
			ast.isLoop.Add(1)
		} else {
			ast.isLoop.Add(-1)
		}
	}
}

func setTryFlag(flag bool, yylex yyLexer) {
	if ast, ok := yylex.(*AstNode); ok {
		if flag {
			ast.isTry.Add(1)
		} else {
			ast.isTry.Add(-1)
		}
	}
}

func createFunctionOrProcedure(Type StatementType, directive Statement, name string, params []ParamStatement, export Statement, variables map[string]VarStatement, body []Statement) *FunctionOrProcedure {
	result := &FunctionOrProcedure{
		Type:              Type,
		Name:              name,
		Body:              body,
		Export:            export != nil && !reflect.ValueOf(export).IsNil(),
		Params:            params,
		ExplicitVariables: variables,
	}

	if tok, ok := directive.(*Token); ok && tok != nil {
		result.Directive = tok.literal
	}

	return result
}

func appendVarStatements(existingVariables map[string]VarStatement, newVariables []Token) (map[string]VarStatement, error) {
	for _, v := range newVariables {
		if _, ok := existingVariables[v.literal]; ok {
			return map[string]VarStatement{}, fmt.Errorf("%w: with the specified name %q", errVariableAlreadyDefined, v.literal)
		} else {
			existingVariables[v.literal] = VarStatement{Name: v.literal}
		}
	}
	return existingVariables, nil
}

func unaryMinus(iv interface{}) interface{} {
	switch v := iv.(type) {
	case int:
		return -v
	case int32:
		return -v
	case int64:
		return -v
	case float32:
		return -v
	case float64:
		return -v
	case IUnary:
		return v.UnaryMinus()
	default:
		return v
	}
}

func not(iv interface{}) interface{} {
	switch v := iv.(type) {
	case bool:
		return !v
	case INot:
		return v.Not()
	default:
		return v
	}
}


***********main.go***************
package main

import (
	"fmt"

	"github.com/LazarenkoA/1c-language-parser/ast"
)

func main() {
	code :=
		`&НаКлиенте
Процедура КомандаВыполнитьКоманду(Команда)                    
	//ПослеВыполненияРасчета(2, НЕОПРЕДЕЛЕНО);
	ОповещенияПослеРачсета = Новый ОписаниеОповещения("ПослеВыполненияРасчета", ЭтотОбъект);
	ВыполнитьОбработкуОповещения(ОповещенияПослеРачсета, 10);
КонецПроцедуры //КомандаВыполнитьКоманду      

&НаКлиенте
Процедура ПослеВыполненияРасчета(Резульат, Параметры) экспорт
	Сообщить("Результат расчета="+СокрЛП(Резульат));
конецПроцедуры //`

	a := ast.NewAST(code)
	if err := a.Parse(); err != nil {
		fmt.Println(err)
		return
	}
	jdata, _ := a.JSON()
	fmt.Println(string(jdata))

	//pf := make(map[string]funcInfo)
	a.ModuleStatement.Walk(func(currentFP *ast.FunctionOrProcedure, statement *ast.Statement) {
		fmt.Println("Walk FunctionOrProcedure", currentFP.Name)
		fmt.Printf("Walk statement %T %v\n", statement, statement)

		// Вывод информации о текущей функции/процедуре
		if currentFP != nil {
			fmt.Printf("\nФункция/Процедура: %s\n", currentFP.Name)
			fmt.Printf("  Export: %v\n", currentFP.Export)
			fmt.Printf("  Type: %v\n", currentFP.Type)
		}
		// Вывод информации о statement
		fmt.Printf("\nStatement тип: %T\n", *statement)
		switch s := (*statement).(type) {
		case ast.MethodStatement:
			fmt.Printf("  Имя метода: %s\n", s.Name)
			fmt.Printf("  Аргументы: %v\n", s.Params)
		case ast.CallChainStatement:
			fmt.Printf("  Цепочка вызовов: %v\n", s.Call)
		case ast.StatementType:
			fmt.Printf("  StatementType: %v\n", s)
		case *ast.FunctionOrProcedure:
			fmt.Printf("  FunctionOrProcedure: %v\n", s)
		default:
			fmt.Printf("  Значение: %+v\n", s)
		}
		fmt.Println("------------------------")

		/*if currentFP == nil {
			return
		}

		key := a.ModuleStatement.Name + "." + currentFP.Name
		if _, ok := pf[key]; !ok {
			pf[key] = funcInfo{id: len(pf), export: currentFP.Export, notUse: true, moduleName: m.ModuleStatement.Name}
		}

		v := pf[key]

		switch value := (*statement).(type) {
		case ast.MethodStatement:
			v.dependence = lo.Union(v.dependence, []string{m.ModuleStatement.Name + "." + value.Name})
		case ast.CallChainStatement:
			if value.IsMethod() {
				v.dependence = append(v.dependence, printCallChainStatement(value))
			}
		}

		if f, ok := (*statement).(*ast.FunctionOrProcedure); ok {
			v.stCount = len(f.Body) + 1
		}

		pf[key] = v
		*/
	})

	//fmt.Println(a.Print(ast.PrintConf{Margin: 4}))
}


***********grammar.y***************
%{
package ast
%}

%type<body> body
%type<opt_body> opt_body
%type<stmt> stmt
%type<stmt_loop> stmt_loop
%type<funcProc> funcProc
%type<stmt_if> stmt_if
%type<opt_elseif_list> opt_elseif_list
%type<opt_else> opt_else
%type<stmt> opt_stmt
%type<stmt> opt_param
%type<exprs> exprs 
%type<stmt> expr
%type<opt_export> opt_export
%type<opt_directive> opt_directive 
%type<stmt> simple_expr
%type<declarations_method_params> declarations_method_params
%type<declarations_method_param> declarations_method_param
%type<stmt> opt_expr
%type<stmt> execute_param
%type<stmt> through_dot
%type<stmt> loopExp
%type<stmt> new_object
%type<stmt> ternary
%type<opt_explicit_variables> opt_explicit_variables
%type<explicit_variables> explicit_variables
%type<identifiers> identifiers
%type<stmt> stmt_tryCatch
%type<stmt> identifier
%type<goToLabel> goToLabel
%type<token> separator
%type<token> semicolon
%type<token> colon
%type<token> ':'
%type<token> ';'
%type<global_variables> global_variables



%union {
    token Token
    stmt_if *IfStatement
    opt_elseif_list []Statement
    opt_else []Statement
    stmt    Statement
    stmt_loop *LoopStatement
    funcProc *FunctionOrProcedure
    body []Statement
    opt_body []Statement
    declarations_method_params []ParamStatement
    declarations_method_param ParamStatement
    exprs []Statement
    opt_export *Token
    opt_directive *Token
    explicit_variables map[string]VarStatement
    global_variables []GlobalVariables
    opt_explicit_variables map[string]VarStatement
    identifiers []Token
    goToLabel *GoToLabelStatement
    opt_goToLabel *GoToLabelStatement
}

%token<token> Directive Identifier Procedure Var EndProcedure If Then ElseIf Else EndIf For Each In To Loop EndLoop Break Not ValueParam While GoToLabel
%token<token> Continue Try Catch EndTry Number String New Function EndFunction Return Throw NeEq Le Ge Or And True False Undefind Export Date GoTo Execute BuiltinFunction


//%right '='
%left Or
%left And
%left NeEq
%left Le
%left Ge
%left Not

%right '='
%left Identifier

//%nonassoc NeEq '>' '<'
//%nonassoc NeEq
//%nonassoc Not
%left '>' '<'
%left '+' '-'
%left '*' '/' '%'
%right UNARMinus UNARYPlus


%%

module: body {
         if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($1, yylex)
        }
    }
    | main_items opt_body {
         if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($2, yylex)
        }
    };

main_items: main
    | main_items main
;

main: global_variables {  
        if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($1, yylex)
        }
    }
    | funcProc {
        if ast, ok := yylex.(*AstNode); ok {
            ast.ModuleStatement.Append($1, yylex)
        }
    }
;

opt_directive:  { $$ = nil}
        | Directive { $$ = &$1}
;

opt_export: { $$ = nil}
        | Export { $$ = &$1}
;

global_variables: opt_directive Var identifiers opt_export semicolon { 
        $$ = make([]GlobalVariables,  len($3), len($3))
        for i, v := range $3 {
            if $1 != nil {
                $$[i].Directive = $1.literal
            }

            $$[i].Export = $4 != nil 
            $$[i].Var = VarStatement { Name: v.literal }
        }
};


funcProc: opt_directive Function Identifier '(' declarations_method_params ')' opt_export { isFunction(true, yylex) } opt_explicit_variables opt_body EndFunction
        {  
            $$ = createFunctionOrProcedure(PFTypeFunction, $1, $3.literal, $5, $7, $9, $10)
            isFunction(false, yylex) 
        }
        | opt_directive Procedure Identifier '(' declarations_method_params ')' opt_export opt_explicit_variables opt_body EndProcedure
        { 
            $$ = createFunctionOrProcedure(PFTypeProcedure, $1, $3.literal, $5, $7, $8, $9)
        }
;

opt_body: { $$ = nil }
	| body { $$ = $1 }
;
    

body: stmt { $$ = []Statement{$1} }
    | opt_body separator opt_stmt { 
        if $2.literal == ":" && len($1) > 0 {
            if _, ok := $1[len($1)-1].(*GoToLabelStatement); !ok {
                yylex.Error("semicolon (;) is expected")
            }
        }
        if $3 != nil {
            $$ = append($$, $3) 
        }
    }
    
;

opt_stmt: { $$ = nil }
        | stmt { $$ = $1 }
;

separator: semicolon { $$ = $1} | colon { $$ = $1};


/* переменные */ 
opt_explicit_variables: { $$ = map[string]VarStatement{} }
            | explicit_variables { $$ = $1 }
;

explicit_variables: Var identifiers semicolon { 
                    if vars, err := appendVarStatements(map[string]VarStatement{}, $2); err != nil {
                        yylex.Error(err.Error()) 
                    } else {
                        $$ = vars
                    }
                }
            | explicit_variables Var identifiers semicolon {
                    if vars, err := appendVarStatements($1, $3); err != nil {
                        yylex.Error(err.Error()) 
                    } else {
                        $$ = vars
                    }
                }
;


/* Если Конецесли */
stmt_if : If expr Then opt_body opt_elseif_list opt_else EndIf {  
    $$ = &IfStatement {
        Expression: $2,
        TrueBlock:  $4,
        IfElseBlock: $5,
        ElseBlock: $6,
    }
};

/* ИначеЕсли */
opt_elseif_list : { $$ = []Statement{} }
        | ElseIf expr Then opt_body opt_elseif_list { 
             $$ = append($5, &IfStatement{
                Expression: $2,
                TrueBlock:  $4,
            })
        };

/* Иначе */
opt_else : { $$ = nil }
        | Else opt_body { $$ = $2 };

/* тернарный оператор */
ternary: '?' '(' expr comma expr comma expr ')' { 
    $$ = TernaryStatement{
            Expression: $3,
            TrueBlock: $5,
            ElseBlock: $7,
        } 
};

/* циклы */
stmt_loop: For Each Identifier In loopExp Loop { setLoopFlag(true, yylex) } opt_body EndLoop {
        $$ = &LoopStatement{
            For: $3.literal,
            In: $5,
            Body: $8,
        }
        setLoopFlag(false, yylex) 
    } 
    | For expr To expr Loop { setLoopFlag(true, yylex) } opt_body EndLoop {
        $$ = &LoopStatement{
            For: $2,
            To: $4,
            Body: $7,
        }
        setLoopFlag(false, yylex)
    }
    |While expr Loop { setLoopFlag(true, yylex) } opt_body EndLoop {
        $$ = &LoopStatement{
            WhileExpr: $2,
            Body: $5,
        }
};


/* описыввает выражения которые можно использовать в циккле Для Каждого */
loopExp: through_dot { $$ = $1 }
        | new_object { $$ = $1 }
        |'(' new_object ')' { $$ = $2 }
;

stmt : expr { $$ = $1 }
    | stmt_if { $$ = $1 }
    | stmt_loop {$$ = $1 }
    | stmt_tryCatch { $$ = $1 }
    | Continue { $$ = ContinueStatement{}; checkLoopOperator($1, yylex) }
    | Break { $$ = BreakStatement{}; checkLoopOperator($1, yylex) }
    | Throw opt_param { $$ = ThrowStatement{ Param: $2 }; checkThrowParam($1, $2, yylex) }
    | Return opt_expr { $$ = &ReturnStatement{ Param: $2 }; checkReturnParam($2, yylex) }
;

opt_param: { $$ = nil } 
            | expr { $$ = $1 }
;


/* вызовы через точку */
through_dot: identifier { $$ = $1 }
        | through_dot dot identifier { $$ = CallChainStatement{ Unit: $3, Call:  $1 } }
;

/* вызовы процедур, функций */
/* вызовы выполнить */
/* выполнить может вызываться так выполнить("что-то") или так выполнить "что-то" */
identifier: Identifier { $$ = VarStatement{ Name: $1.literal } }
        | Identifier '(' exprs ')' { $$ = MethodStatement{ Name: $1.literal, Param: $3 } }
        | identifier '[' expr ']' { $$ = ItemStatement{ Object: $1, Item: $3 } }
        | Execute execute_param { $$ = MethodStatement{ Name: $1.literal, Param: []Statement{$2} } }
        | Execute '(' expr ')' { $$ = MethodStatement{ Name: $1.literal, Param:  []Statement{$3} } }
        | BuiltinFunction '(' exprs ')' { $$ = &BuiltinFunctionStatement{ Name: $1.literal, Param: $3 } }
;

execute_param: String { $$ = $1.value  }
             | Identifier { $$ = VarStatement{ Name: $1.literal }};

/* попытка */
stmt_tryCatch: Try opt_body Catch { setTryFlag(true, yylex) } opt_body EndTry { 
    $$ = TryStatement{ Body: $2, Catch: $5 }
    setTryFlag(false, yylex)
};

/* выражения */
expr : simple_expr { $$ = $1 }
    |'(' expr ')' { $$ = $2 }
    | expr '+' expr { $$ = &ExpStatement{Operation: OpPlus, Left: $1, Right: $3} }
    | expr '-' expr { $$ = &ExpStatement{Operation: OpMinus, Left: $1, Right: $3} }
    | expr '*' expr { $$ = &ExpStatement{Operation: OpMul, Left: $1, Right: $3} }
    | expr '/' expr { $$ = &ExpStatement{Operation: OpDiv, Left: $1, Right: $3} }
    | expr '%' expr { $$ = &ExpStatement{Operation: OpMod, Left: $1, Right: $3} }
    | expr '>' expr { $$ = &ExpStatement{Operation: OpGt, Left: $1, Right: $3} }
    | expr '<' expr { $$ = &ExpStatement{Operation: OpLt, Left: $1, Right: $3} }
	| expr '=' expr { $$ = &ExpStatement{Operation: OpEq, Left: $1, Right: $3 } }
    | expr Or expr {  $$ = &ExpStatement{Operation: OpOr, Left: $1, Right: $3 } } 
    | expr And expr { $$ = &ExpStatement{Operation: OpAnd, Left: $1, Right: $3 } } 
    | expr NeEq expr { $$ = &ExpStatement{Operation: OpNe, Left: $1, Right: $3 } }
    | expr Le expr { $$ = &ExpStatement{Operation: OpLe, Left: $1, Right: $3 } }
    | expr Ge expr { $$ = &ExpStatement{Operation: OpGe, Left: $1, Right: $3 } }
    | Not expr { $$ = not($2) }
    | new_object { $$ = $1 } 
    | GoTo goToLabel { $$ = GoToStatement{ Label: $2 } }
;

opt_expr: { $$ = nil } | expr { $$ = $1 };

// опиасываются правила по которым можно объявлять параметры в функции или процедуре
declarations_method_param: Identifier {  $$ = *(&ParamStatement{}).Fill(nil, $1) } // обычный параметр
            | ValueParam Identifier { $$ = *(&ParamStatement{}).Fill(&$1, $2) } // знач
            | declarations_method_param '=' simple_expr { $$ = *($$.DefaultValue($3)) } // необязательный параметр 
;

declarations_method_params : { $$ = []ParamStatement{} }
                | declarations_method_param  { $$ = []ParamStatement{$1} }
                | declarations_method_params comma declarations_method_param { $$ = append($1, $3) }
;

// для ключевого слова Новый
// 1С допускает такие конструкции
// новый Структура(), новый Массив() ...
// но так же и такие
// Новый("РегистрСведенийКлючЗаписи.СостоянияОригиналовПервичныхДокументов", ПараметрыМассив);
new_object:  New Identifier { $$ = NewObjectStatement{ Constructor: $2.literal } }
            | New Identifier '(' exprs ')' { $$ = NewObjectStatement{ Constructor: $2.literal, Param: $4 } }
            | New '(' exprs ')' { $$ = NewObjectStatement{ Param: $3 } }
;

simple_expr:  String { $$ = $1.value  }
            | Number { $$ =  $1.value }
            | '-' expr %prec UNARMinus { $$ = unaryMinus($2) }
            | '+' expr %prec UNARYPlus { $$ = $2 }
            | True { $$ =  $1.value  }
            | False { $$ =  $1.value  }
            | Date { $$ =  $1.value  }
            | Undefind { $$ = UndefinedStatement{} }
            | goToLabel { $$ = $1}
            | through_dot { 
                if tok, ok := $1.(Token); ok {
                    $$ = tok.literal
                } else {
                    $$ =  $1
                }
            }
            | ternary { $$ =  $1  } // тернарный оператор
;

goToLabel: GoToLabel { $$ = &GoToLabelStatement{ Name: $1.literal } }

exprs : opt_expr {$$ = []Statement{$1} }
	| exprs comma opt_expr { $$ = append($$, $3);  }
;    

identifiers: Identifier { $$ = []Token{$1} }
        | identifiers comma Identifier {$$ = append($$, $3) }
;

semicolon: ';' {$$ = $1};
colon: ':'{$$ = $1};
comma: ',';
dot: '.';

%%


***********ast_struct.go***************
package ast

import (
	"fmt"
	"strings"
)

type StatementType int
type OperationType int

const (
	PFTypeUndefined StatementType = iota
	PFTypeProcedure
	PFTypeFunction
)

const (
	OpPlus OperationType = iota
	OpMinus
	OpMul
	OpDiv
	OpEq  // =
	OpGt  // >
	OpLt  // <
	OpNe  // <>
	OpLe  // <=
	OpGe  // >=
	OpMod // % - деление по модулю
	OpOr
	OpAnd
)

type IUnary interface {
	UnaryMinus() interface{}
}

type INot interface {
	Not() interface{}
}

type IParams interface {
	Params() []Statement
}

type Statement interface{}

type GlobalVariables struct {
	Directive string
	Var       VarStatement
	Export    bool
}

type ModuleStatement struct {
	Name            string
	GlobalVariables map[string]GlobalVariables `json:"GlobalVariables,omitempty"`
	Body            []Statement
}

type VarStatement struct {
	Name string
	addStatementField
}

type FunctionOrProcedure struct {
	ExplicitVariables map[string]VarStatement
	Name              string
	Directive         string
	Body              []Statement
	Params            []ParamStatement
	Type              StatementType
	Export            bool
}

type ParamStatement struct {
	Default Statement `json:"Default,omitempty"`
	Name    string
	IsValue bool `json:"IsValue,omitempty"`
}

type addStatementField struct {
	unaryMinus bool
	unaryPlus  bool
	not        bool
}

type ExpStatement struct {
	Left      interface{}
	Right     interface{}
	Operation OperationType
	addStatementField
}

// type IfElseStatement struct {
// 	Expression Statement
// 	TrueBlock  []Statement
// }

type IfStatement struct {
	Expression  Statement
	TrueBlock   []Statement
	IfElseBlock []Statement
	ElseBlock   []Statement
}

type TryStatement struct {
	Body  []Statement
	Catch []Statement
}

type ThrowStatement struct {
	Param Statement
}

type UndefinedStatement struct{}

type ReturnStatement struct {
	Param Statement
}

type NewObjectStatement struct {
	Constructor string
	Param       []Statement
}

type CallChainStatement struct {
	Unit Statement
	Call Statement
	addStatementField
}

type MethodStatement struct {
	Name  string
	Param []Statement
	addStatementField
}

type BreakStatement struct {
}

type ContinueStatement struct {
}

type LoopStatement struct {
	For       Statement `json:"For,omitempty"`
	To        Statement `json:"To,omitempty"`
	In        Statement `json:"In,omitempty"`
	WhileExpr Statement `json:"WhileExpr,omitempty"`
	Body      []Statement
}

type TernaryStatement struct {
	Expression Statement
	TrueBlock  Statement
	ElseBlock  Statement
}

type ItemStatement struct {
	Item   Statement
	Object Statement
}

type GoToStatement struct {
	Label *GoToLabelStatement
}

type GoToLabelStatement struct {
	Name string
}

type BuiltinFunctionStatement struct {
	Name  string
	Param []Statement
}

var ierahiy = 0

func (p *ParamStatement) Fill(valueParam *Token, identifier Token) *ParamStatement {
	p.IsValue = valueParam != nil
	p.Name = identifier.literal
	return p
}

func (p *ParamStatement) DefaultValue(value Statement) *ParamStatement {
	if value == nil {
		p.Default = UndefinedStatement{}
	} else {
		p.Default = value
	}

	return p
}

func (e *ExpStatement) UnaryMinus() interface{} {
	e.unaryMinus = true
	return e
}

func (e *ExpStatement) Not() interface{} {
	e.not = true
	return e
}

func (e VarStatement) UnaryMinus() interface{} {
	e.unaryMinus = true
	return e
}

func (e VarStatement) Not() interface{} {
	e.not = true
	return e
}

func (e CallChainStatement) UnaryMinus() interface{} {
	e.unaryMinus = true
	return e
}

func (e CallChainStatement) Not() interface{} {
	e.not = true
	return e
}

// IsMethod вернет true в случаях Блокировка.Заблокировать() и false для Источник.Ссылка
func (e CallChainStatement) IsMethod() bool {
	_, ok := e.Unit.(MethodStatement)
	return ok
}

func (e MethodStatement) Not() interface{} {
	e.not = true
	return e
}

func (n NewObjectStatement) Params() []Statement {
	return n.Param
}

func (n MethodStatement) Params() []Statement {
	return n.Param
}

func (o OperationType) String() string {
	switch o {
	case OpPlus:
		return "+"
	case OpMinus:
		return "-"
	case OpMul:
		return "*"
	case OpDiv:
		return "/"
	case OpEq:
		return "="
	case OpGt:
		return ">"
	case OpLt:
		return "<"
	case OpNe:
		return "<>"
	case OpLe:
		return "<="
	case OpGe:
		return ">="
	case OpMod:
		return "%"
	case OpOr:
		return "ИЛИ"
	case OpAnd:
		return "И"
	default:
		return ""
	}
}

func (m ModuleStatement) Walk(callBack func(current *FunctionOrProcedure, statement *Statement)) {
	fmt.Println("Walk ModuleStatement", m.Name)
	StatementWalk(m.Body, callBack)
}

func StatementWalk(stm []Statement, callBack func(current *FunctionOrProcedure, statement *Statement)) {
	fmt.Println("StatementWalk:", len(stm))
	walkHelper(nil, stm, callBack)
}

func (m *ModuleStatement) Append(item Statement, yylex yyLexer) {
	switch v := item.(type) {
	case GlobalVariables:
		if len(m.Body) > 0 {
			yylex.Error("variable declarations must be placed at the beginning of the module")
			return
		}

		if m.GlobalVariables == nil {
			m.GlobalVariables = map[string]GlobalVariables{}
		}

		if _, ok := m.GlobalVariables[v.Var.Name]; ok {
			yylex.Error(fmt.Sprintf("%v: with the specified name %q", errVariableAlreadyDefined, v.Var.Name))
		} else {
			m.GlobalVariables[v.Var.Name] = v
		}
	case []GlobalVariables:
		for _, item := range v {
			m.Append(item, yylex)
		}
	case []Statement:
		m.Body = append(m.Body, v...)
	case *FunctionOrProcedure:
		// если предыдущее выражение не процедура функция, то это значит что какой-то умник вначале или в середине модуля вставил какие-то выражения, а это нельзя. 1С разрешает выражения только в конце модуля
		if len(m.Body) > 0 {
			if _, ok := m.Body[len(m.Body)-1].(*FunctionOrProcedure); !ok {
				yylex.Error("procedure and function definitions should be placed before the module body statements")
				return
			}
		}

		m.Body = append(m.Body, item)
	default:
		m.Body = append(m.Body, item)
	}
}

// func (m Statements) Walk(callBack func(statement *Statement)) {
// 	walkHelper(m, callBack)
// }

func walkHelper(parent *FunctionOrProcedure, statements []Statement, callBack func(current *FunctionOrProcedure, statement *Statement)) {
	ierahiy = ierahiy + 1
	otstup := strings.Repeat(" ", ierahiy)
	fmt.Printf("%swalkHelper parent: %T %v %v\n", otstup, parent, parent, ierahiy)
	fmt.Printf("%swalkHelper statements: %d %T %v\n", otstup, len(statements), statements, statements)
	//fmt.Printf("walkHelper current: %T %v\n", current, current)
	for i, item := range statements {
		fmt.Printf("%swalkHelper item: %d %T %v\n", otstup, i, item, item)
		switch v := item.(type) {
		case *IfStatement:
			fmt.Printf("%sIfStatement %v\n", otstup, v.Expression)
			walkHelper(parent, []Statement{v.Expression}, callBack)
			walkHelper(parent, v.TrueBlock, callBack)
			walkHelper(parent, v.ElseBlock, callBack)
			walkHelper(parent, v.IfElseBlock, callBack)
		case TryStatement:
			fmt.Printf("%sTryStatement\n", otstup)
			walkHelper(parent, v.Body, callBack)
			walkHelper(parent, v.Catch, callBack)
		case *LoopStatement:
			fmt.Printf("%sLoopStatement\n", otstup)
			walkHelper(parent, v.Body, callBack)
		case *FunctionOrProcedure:
			fmt.Printf("%sFunctionOrProcedure\n", otstup)
			walkHelper(v, v.Body, callBack)
			parent = v
		case MethodStatement:
			fmt.Printf("%sMethodStatement\n", otstup)
			walkHelper(parent, v.Param, callBack)
		//case CallChainStatement:
		//	walkHelper(parent, []Statement{v.Unit}, callBack)
		case *ExpStatement:
			fmt.Printf("%sExpStatement\n", otstup)
			walkHelper(parent, []Statement{v.Right}, callBack)
			walkHelper(parent, []Statement{v.Left}, callBack)
		case TernaryStatement:
			fmt.Printf("%sTernaryStatement\n", otstup)
			walkHelper(parent, []Statement{v.Expression}, callBack)
			walkHelper(parent, []Statement{v.TrueBlock}, callBack)
			walkHelper(parent, []Statement{v.ElseBlock}, callBack)
		case *ReturnStatement:
			fmt.Printf("%sReturnStatement\n", otstup)
			walkHelper(parent, []Statement{v.Param}, callBack)
		case BuiltinFunctionStatement:
			fmt.Printf("%sBuiltinFunctionStatement %v %d\n", otstup, v.Name, len(v.Param))
			walkHelper(parent, v.Param, callBack)
		}
		fmt.Printf("%scallBack %T %v\n", otstup, parent, statements[i])
		callBack(parent, &statements[i])
	}
}


***********y.go***************
// Code generated by goyacc -o ast/y.go ast/grammar.y. DO NOT EDIT.

//line ast/grammar.y:1

package ast

import __yyfmt__ "fmt"

//line ast/grammar.y:3

//line ast/grammar.y:43
type yySymType struct {
	yys                        int
	token                      Token
	stmt_if                    *IfStatement
	opt_elseif_list            []Statement
	opt_else                   []Statement
	stmt                       Statement
	stmt_loop                  *LoopStatement
	funcProc                   *FunctionOrProcedure
	body                       []Statement
	opt_body                   []Statement
	declarations_method_params []ParamStatement
	declarations_method_param  ParamStatement
	exprs                      []Statement
	opt_export                 *Token
	opt_directive              *Token
	explicit_variables         map[string]VarStatement
	global_variables           []GlobalVariables
	opt_explicit_variables     map[string]VarStatement
	identifiers                []Token
	goToLabel                  *GoToLabelStatement
	opt_goToLabel              *GoToLabelStatement
}

const Directive = 57346
const Identifier = 57347
const Procedure = 57348
const Var = 57349
const EndProcedure = 57350
const If = 57351
const Then = 57352
const ElseIf = 57353
const Else = 57354
const EndIf = 57355
const For = 57356
const Each = 57357
const In = 57358
const To = 57359
const Loop = 57360
const EndLoop = 57361
const Break = 57362
const Not = 57363
const ValueParam = 57364
const While = 57365
const GoToLabel = 57366
const Continue = 57367
const Try = 57368
const Catch = 57369
const EndTry = 57370
const Number = 57371
const String = 57372
const New = 57373
const Function = 57374
const EndFunction = 57375
const Return = 57376
const Throw = 57377
const NeEq = 57378
const Le = 57379
const Ge = 57380
const Or = 57381
const And = 57382
const True = 57383
const False = 57384
const Undefind = 57385
const Export = 57386
const Date = 57387
const GoTo = 57388
const Execute = 57389
const BuiltinFunction = 57390
const UNARMinus = 57391
const UNARYPlus = 57392

var yyToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"':'",
	"';'",
	"Directive",
	"Identifier",
	"Procedure",
	"Var",
	"EndProcedure",
	"If",
	"Then",
	"ElseIf",
	"Else",
	"EndIf",
	"For",
	"Each",
	"In",
	"To",
	"Loop",
	"EndLoop",
	"Break",
	"Not",
	"ValueParam",
	"While",
	"GoToLabel",
	"Continue",
	"Try",
	"Catch",
	"EndTry",
	"Number",
	"String",
	"New",
	"Function",
	"EndFunction",
	"Return",
	"Throw",
	"NeEq",
	"Le",
	"Ge",
	"Or",
	"And",
	"True",
	"False",
	"Undefind",
	"Export",
	"Date",
	"GoTo",
	"Execute",
	"BuiltinFunction",
	"'='",
	"'>'",
	"'<'",
	"'+'",
	"'-'",
	"'*'",
	"'/'",
	"'%'",
	"UNARMinus",
	"UNARYPlus",
	"'('",
	"')'",
	"'?'",
	"'['",
	"']'",
	"','",
	"'.'",
}

var yyStatenames = [...]string{}

const yyEofCode = 1
const yyErrCode = 2
const yyInitialStackSize = 16

//line ast/grammar.y:380

//line yacctab:1
var yyExca = [...]int8{
	-1, 0,
	4, 15,
	5, 15,
	-2, 7,
	-1, 1,
	1, -1,
	-2, 0,
	-1, 2,
	1, 1,
	-2, 16,
	-1, 3,
	8, 7,
	9, 7,
	34, 7,
	-2, 15,
}

const yyPrivate = 57344

const yyLast = 628

var yyAct = [...]uint8{
	143, 7, 5, 117, 50, 197, 46, 149, 135, 20,
	160, 17, 124, 161, 36, 68, 70, 41, 52, 180,
	71, 72, 85, 138, 74, 76, 77, 69, 78, 88,
	123, 82, 83, 64, 65, 66, 62, 63, 176, 165,
	148, 146, 138, 138, 138, 138, 61, 59, 60, 54,
	55, 56, 57, 58, 137, 186, 98, 99, 100, 101,
	102, 103, 104, 105, 106, 107, 108, 109, 110, 142,
	66, 86, 140, 138, 138, 94, 139, 43, 122, 138,
	95, 61, 59, 60, 54, 55, 56, 57, 58, 70,
	125, 126, 70, 90, 128, 65, 66, 70, 89, 4,
	93, 43, 121, 38, 56, 57, 58, 61, 59, 60,
	54, 55, 56, 57, 58, 130, 132, 178, 136, 44,
	45, 127, 137, 38, 70, 87, 129, 145, 40, 92,
	171, 154, 53, 52, 81, 79, 156, 157, 162, 131,
	158, 153, 182, 44, 45, 70, 152, 167, 169, 97,
	118, 164, 170, 141, 205, 163, 166, 199, 53, 52,
	80, 177, 179, 211, 172, 177, 53, 52, 181, 53,
	52, 159, 183, 120, 119, 150, 187, 113, 52, 64,
	65, 66, 134, 192, 175, 188, 202, 193, 194, 191,
	190, 189, 61, 59, 60, 54, 55, 56, 57, 58,
	204, 201, 203, 206, 53, 52, 207, 136, 35, 209,
	136, 210, 39, 43, 212, 53, 52, 22, 53, 52,
	84, 195, 23, 54, 55, 56, 57, 58, 12, 19,
	73, 24, 40, 11, 25, 174, 133, 28, 27, 38,
	116, 173, 14, 13, 53, 52, 53, 52, 185, 31,
	32, 34, 208, 33, 21, 44, 45, 196, 6, 43,
	30, 29, 47, 22, 48, 2, 3, 18, 23, 42,
	1, 15, 51, 49, 12, 19, 10, 24, 40, 11,
	25, 198, 37, 28, 27, 38, 151, 91, 14, 13,
	26, 67, 96, 43, 168, 31, 32, 34, 8, 33,
	21, 44, 45, 75, 16, 9, 30, 29, 0, 19,
	0, 0, 40, 18, 0, 42, 0, 28, 27, 38,
	0, 0, 0, 0, 0, 0, 43, 0, 0, 31,
	32, 34, 0, 33, 21, 44, 45, 0, 0, 0,
	30, 29, 19, 0, 0, 40, 0, 18, 0, 42,
	28, 27, 38, 61, 59, 60, 54, 55, 56, 57,
	58, 0, 31, 32, 34, 0, 33, 21, 44, 45,
	0, 0, 0, 30, 29, 64, 65, 66, 62, 63,
	18, 0, 42, 0, 0, 0, 0, 0, 61, 59,
	60, 54, 55, 56, 57, 58, 64, 65, 66, 62,
	63, 0, 0, 138, 0, 0, 0, 0, 0, 61,
	59, 60, 54, 55, 56, 57, 58, 64, 65, 66,
	62, 63, 0, 144, 43, 0, 0, 0, 0, 0,
	61, 59, 60, 54, 55, 56, 57, 58, 64, 65,
	66, 200, 63, 40, 0, 0, 0, 0, 28, 27,
	0, 61, 59, 60, 54, 55, 56, 57, 58, 0,
	31, 32, 34, 0, 33, 0, 44, 45, 0, 0,
	0, 30, 29, 64, 65, 66, 62, 63, 0, 0,
	42, 0, 0, 0, 0, 0, 61, 59, 60, 54,
	55, 56, 57, 58, 0, 0, 0, 147, 64, 65,
	66, 62, 63, 184, 0, 0, 0, 0, 0, 0,
	0, 61, 59, 60, 54, 55, 56, 57, 58, 155,
	0, 0, 111, 0, 0, 0, 0, 0, 0, 64,
	65, 66, 62, 63, 0, 0, 0, 64, 65, 66,
	62, 63, 61, 59, 60, 54, 55, 56, 57, 58,
	61, 59, 60, 54, 55, 56, 57, 58, 115, 0,
	0, 0, 0, 0, 0, 114, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 64, 65, 66, 62,
	63, 112, 0, 0, 64, 65, 66, 62, 63, 61,
	59, 60, 54, 55, 56, 57, 58, 61, 59, 60,
	54, 55, 56, 57, 58, 0, 0, 64, 65, 66,
	62, 63, 0, 0, 0, 0, 0, 0, 0, 0,
	61, 59, 60, 54, 55, 56, 57, 58,
}

var yyPact = [...]int16{
	206, -1000, -1000, 206, -1000, 240, -1000, -5, -1000, -1000,
	-1000, -1000, -1000, 319, 319, -1000, -1000, -1000, 319, 319,
	-1000, 102, 319, 286, 319, 252, 126, -1000, -1000, 319,
	319, -1000, -1000, -1000, -1000, -1000, -45, -1000, 64, -1000,
	-1000, -35, 37, 32, 68, 19, 240, -1000, -1000, 252,
	-1000, -1000, -1000, -1000, 319, 319, 319, 319, 319, 319,
	319, 319, 319, 319, 319, 319, 319, -1000, -5, -1000,
	-5, 460, 302, -1000, 569, 170, 546, 538, 211, 143,
	167, 166, -1000, -1000, 94, -1000, 17, 319, 319, 319,
	319, -1000, 319, -1000, -1000, 319, -1000, -1000, 48, 48,
	-1000, -1000, -1000, 169, 169, 302, 400, 141, 56, 30,
	302, -1000, 252, 121, 319, -1000, -1000, 8, -1000, 15,
	11, -35, 319, 7, -1000, 358, 337, -21, 435, -22,
	162, 70, 499, 252, 252, 173, 164, -1000, -1000, 131,
	131, -23, -1000, 319, -1000, 319, -1000, -1000, -1000, 134,
	319, 110, -45, -1000, 90, -1000, 214, 154, -1000, -1000,
	-24, 66, -1000, 155, -43, -1000, -1000, 337, 127, 252,
	491, -1000, -7, 252, -1000, -1000, 76, 131, 417, -1000,
	76, 319, -1000, 240, 252, 252, -1000, 200, -1000, 66,
	-1000, 148, 379, 162, 165, -1000, 148, 252, 145, 143,
	-1000, -1000, -1000, 252, 242, 143, 13, 128, -1000, 13,
	-1000, -1000, -1000,
}

var yyPgo = [...]int16{
	0, 264, 2, 99, 305, 304, 298, 7, 294, 292,
	291, 30, 1, 8, 290, 11, 10, 13, 12, 287,
	14, 286, 9, 282, 5, 281, 3, 276, 17, 208,
	273, 4, 272, 271, 270, 266, 258, 257, 0, 248,
	241, 236, 220, 182,
}

var yyR1 = [...]int8{
	0, 34, 34, 35, 35, 36, 36, 14, 14, 13,
	13, 33, 37, 5, 5, 2, 2, 1, 1, 9,
	9, 30, 30, 24, 24, 25, 25, 6, 7, 7,
	8, 8, 23, 39, 4, 40, 4, 41, 4, 21,
	21, 21, 3, 3, 3, 3, 3, 3, 3, 3,
	10, 10, 20, 20, 28, 28, 28, 28, 28, 28,
	19, 19, 43, 27, 12, 12, 12, 12, 12, 12,
	12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
	12, 12, 18, 18, 17, 17, 17, 16, 16, 16,
	22, 22, 22, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 29, 11, 11, 26, 26, 31,
	32, 38, 42,
}

var yyR2 = [...]int8{
	0, 1, 2, 1, 2, 1, 1, 0, 1, 0,
	1, 5, 0, 11, 10, 0, 1, 1, 3, 0,
	1, 1, 1, 0, 1, 3, 4, 7, 0, 5,
	0, 2, 8, 0, 9, 0, 8, 0, 6, 1,
	1, 3, 1, 1, 1, 1, 1, 1, 2, 2,
	0, 1, 1, 3, 1, 4, 4, 2, 4, 4,
	1, 1, 0, 6, 1, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 2,
	1, 2, 0, 1, 1, 2, 3, 0, 1, 3,
	2, 5, 4, 1, 1, 2, 2, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 3, 1, 3, 1,
	1, 1, 1,
}

var yyChk = [...]int16{
	-1000, -34, -1, -35, -3, -2, -36, -12, -6, -4,
	-27, 27, 22, 37, 36, -33, -5, -15, 61, 23,
	-22, 48, 11, 16, 25, 28, -14, 32, 31, 55,
	54, 43, 44, 47, 45, -29, -20, -23, 33, 6,
	26, -28, 63, 7, 49, 50, -2, -36, -1, -30,
	-31, -32, 5, 4, 54, 55, 56, 57, 58, 52,
	53, 51, 41, 42, 38, 39, 40, -10, -12, -18,
	-12, -12, -12, -29, -12, 17, -12, -12, -2, 9,
	34, 8, -12, -12, -42, 67, 7, 61, 64, 61,
	61, -19, 61, 32, 7, 61, -9, -3, -12, -12,
	-12, -12, -12, -12, -12, -12, -12, -12, -12, -12,
	-12, 62, 12, 7, 19, 20, 29, -26, 7, 7,
	7, -28, 61, -11, -18, -12, -12, -11, -12, -11,
	-2, 18, -12, -41, -43, -13, -38, 46, 66, 61,
	61, -11, 62, -38, 65, -38, 62, 62, 62, -7,
	13, -21, -20, -22, 61, 20, -2, -2, -31, 7,
	-16, -17, 7, 24, -16, 62, -18, -12, -8, 14,
	-12, 20, -22, -40, 21, 30, 62, -38, 51, 7,
	62, -38, 15, -2, 12, -39, 62, -2, -13, -17,
	-15, -13, -12, -2, -2, 21, -37, -24, -25, 9,
	62, -7, 21, -24, -2, 9, -26, -2, 10, -26,
	-31, 35, -31,
}

var yyDef = [...]int8{
	-2, -2, -2, -2, 17, 0, 3, 42, 43, 44,
	45, 46, 47, 50, 82, 5, 6, 64, 0, 0,
	80, 0, 0, 0, 0, 15, 0, 93, 94, 0,
	0, 97, 98, 99, 100, 101, 102, 103, 0, 8,
	104, 52, 0, 54, 0, 0, 2, 4, 16, 19,
	21, 22, 109, 110, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 48, 51, 49,
	83, 0, 79, 81, 0, 0, 0, 0, 0, 0,
	0, 0, 95, 96, 0, 112, 90, 82, 0, 0,
	82, 57, 0, 60, 61, 82, 18, 20, 66, 67,
	68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
	78, 65, 15, 0, 0, 37, 62, 9, 107, 0,
	0, 53, 82, 0, 105, 0, 0, 0, 0, 0,
	28, 0, 0, 15, 15, 0, 0, 10, 111, 87,
	87, 0, 92, 82, 56, 0, 55, 58, 59, 30,
	0, 0, 39, 40, 0, 35, 0, 0, 11, 108,
	0, 88, 84, 0, 0, 91, 106, 0, 0, 15,
	0, 33, 0, 15, 38, 63, 9, 0, 0, 85,
	9, 0, 27, 31, 15, 15, 41, 0, 12, 89,
	86, 23, 0, 28, 0, 36, 23, 15, 24, 0,
	32, 29, 34, 15, 0, 0, 0, 0, 14, 0,
	25, 13, 26,
}

var yyTok1 = [...]int8{
	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 58, 3, 3,
	61, 62, 56, 54, 66, 55, 67, 57, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 4, 5,
	53, 51, 52, 63, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 64, 3, 65,
}

var yyTok2 = [...]int8{
	2, 3, 6, 7, 8, 9, 10, 11, 12, 13,
	14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
	34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
	44, 45, 46, 47, 48, 49, 50, 59, 60,
}

var yyTok3 = [...]int8{
	0,
}

var yyErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	yyDebug        = 0
	yyErrorVerbose = false
)

type yyLexer interface {
	Lex(lval *yySymType) int
	Error(s string)
}

type yyParser interface {
	Parse(yyLexer) int
	Lookahead() int
}

type yyParserImpl struct {
	lval  yySymType
	stack [yyInitialStackSize]yySymType
	char  int
}

func (p *yyParserImpl) Lookahead() int {
	return p.char
}

func yyNewParser() yyParser {
	return &yyParserImpl{}
}

const yyFlag = -1000

func yyTokname(c int) string {
	if c >= 1 && c-1 < len(yyToknames) {
		if yyToknames[c-1] != "" {
			return yyToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func yyStatname(s int) string {
	if s >= 0 && s < len(yyStatenames) {
		if yyStatenames[s] != "" {
			return yyStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func yyErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !yyErrorVerbose {
		return "syntax error"
	}

	for _, e := range yyErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + yyTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(yyPact[state])
	for tok := TOKSTART; tok-1 < len(yyToknames); tok++ {
		if n := base + tok; n >= 0 && n < yyLast && int(yyChk[int(yyAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if yyDef[state] == -2 {
		i := 0
		for yyExca[i] != -1 || int(yyExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; yyExca[i] >= 0; i += 2 {
			tok := int(yyExca[i])
			if tok < TOKSTART || yyExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if yyExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += yyTokname(tok)
	}
	return res
}

func yylex1(lex yyLexer, lval *yySymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(yyTok1[0])
		goto out
	}
	if char < len(yyTok1) {
		token = int(yyTok1[char])
		goto out
	}
	if char >= yyPrivate {
		if char < yyPrivate+len(yyTok2) {
			token = int(yyTok2[char-yyPrivate])
			goto out
		}
	}
	for i := 0; i < len(yyTok3); i += 2 {
		token = int(yyTok3[i+0])
		if token == char {
			token = int(yyTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(yyTok2[1]) /* unknown char */
	}
	if yyDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", yyTokname(token), uint(char))
	}
	return char, token
}

func yyParse(yylex yyLexer) int {
	return yyNewParser().Parse(yylex)
}

func (yyrcvr *yyParserImpl) Parse(yylex yyLexer) int {
	var yyn int
	var yyVAL yySymType
	var yyDollar []yySymType
	_ = yyDollar // silence set and not used
	yyS := yyrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	yystate := 0
	yyrcvr.char = -1
	yytoken := -1 // yyrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		yystate = -1
		yyrcvr.char = -1
		yytoken = -1
	}()
	yyp := -1
	goto yystack

ret0:
	return 0

ret1:
	return 1

yystack:
	/* put a state and value onto the stack */
	if yyDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", yyTokname(yytoken), yyStatname(yystate))
	}

	yyp++
	if yyp >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyS[yyp] = yyVAL
	yyS[yyp].yys = yystate

yynewstate:
	yyn = int(yyPact[yystate])
	if yyn <= yyFlag {
		goto yydefault /* simple state */
	}
	if yyrcvr.char < 0 {
		yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
	}
	yyn += yytoken
	if yyn < 0 || yyn >= yyLast {
		goto yydefault
	}
	yyn = int(yyAct[yyn])
	if int(yyChk[yyn]) == yytoken { /* valid shift */
		yyrcvr.char = -1
		yytoken = -1
		yyVAL = yyrcvr.lval
		yystate = yyn
		if Errflag > 0 {
			Errflag--
		}
		goto yystack
	}

yydefault:
	/* default state action */
	yyn = int(yyDef[yystate])
	if yyn == -2 {
		if yyrcvr.char < 0 {
			yyrcvr.char, yytoken = yylex1(yylex, &yyrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if yyExca[xi+0] == -1 && int(yyExca[xi+1]) == yystate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			yyn = int(yyExca[xi+0])
			if yyn < 0 || yyn == yytoken {
				break
			}
		}
		yyn = int(yyExca[xi+1])
		if yyn < 0 {
			goto ret0
		}
	}
	if yyn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			yylex.Error(yyErrorMessage(yystate, yytoken))
			Nerrs++
			if yyDebug >= 1 {
				__yyfmt__.Printf("%s", yyStatname(yystate))
				__yyfmt__.Printf(" saw %s\n", yyTokname(yytoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for yyp >= 0 {
				yyn = int(yyPact[yyS[yyp].yys]) + yyErrCode
				if yyn >= 0 && yyn < yyLast {
					yystate = int(yyAct[yyn]) /* simulate a shift of "error" */
					if int(yyChk[yystate]) == yyErrCode {
						goto yystack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if yyDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", yyS[yyp].yys)
				}
				yyp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if yyDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", yyTokname(yytoken))
			}
			if yytoken == yyEofCode {
				goto ret1
			}
			yyrcvr.char = -1
			yytoken = -1
			goto yynewstate /* try again in the same state */
		}
	}

	/* reduction by production yyn */
	if yyDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", yyn, yyStatname(yystate))
	}

	yynt := yyn
	yypt := yyp
	_ = yypt // guard against "declared and not used"

	yyp -= int(yyR2[yyn])
	// yyp is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if yyp+1 >= len(yyS) {
		nyys := make([]yySymType, len(yyS)*2)
		copy(nyys, yyS)
		yyS = nyys
	}
	yyVAL = yyS[yyp+1]

	/* consult goto table to find next state */
	yyn = int(yyR1[yyn])
	yyg := int(yyPgo[yyn])
	yyj := yyg + yyS[yyp].yys + 1

	if yyj >= yyLast {
		yystate = int(yyAct[yyg])
	} else {
		yystate = int(yyAct[yyj])
		if int(yyChk[yystate]) != -yyn {
			yystate = int(yyAct[yyg])
		}
	}
	// dummy call; replaced with literal code
	switch yynt {

	case 1:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:92
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[1].body, yylex)
			}
		}
	case 2:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:97
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[2].opt_body, yylex)
			}
		}
	case 5:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:107
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[1].global_variables, yylex)
			}
		}
	case 6:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:112
		{
			if ast, ok := yylex.(*AstNode); ok {
				ast.ModuleStatement.Append(yyDollar[1].funcProc, yylex)
			}
		}
	case 7:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:119
		{
			yyVAL.opt_directive = nil
		}
	case 8:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:120
		{
			yyVAL.opt_directive = &yyDollar[1].token
		}
	case 9:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:123
		{
			yyVAL.opt_export = nil
		}
	case 10:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:124
		{
			yyVAL.opt_export = &yyDollar[1].token
		}
	case 11:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:127
		{
			yyVAL.global_variables = make([]GlobalVariables, len(yyDollar[3].identifiers), len(yyDollar[3].identifiers))
			for i, v := range yyDollar[3].identifiers {
				if yyDollar[1].opt_directive != nil {
					yyVAL.global_variables[i].Directive = yyDollar[1].opt_directive.literal
				}

				yyVAL.global_variables[i].Export = yyDollar[4].opt_export != nil
				yyVAL.global_variables[i].Var = VarStatement{Name: v.literal}
			}
		}
	case 12:
		yyDollar = yyS[yypt-7 : yypt+1]
//line ast/grammar.y:140
		{
			isFunction(true, yylex)
		}
	case 13:
		yyDollar = yyS[yypt-11 : yypt+1]
//line ast/grammar.y:141
		{
			yyVAL.funcProc = createFunctionOrProcedure(PFTypeFunction, yyDollar[1].opt_directive, yyDollar[3].token.literal, yyDollar[5].declarations_method_params, yyDollar[7].opt_export, yyDollar[9].opt_explicit_variables, yyDollar[10].opt_body)
			isFunction(false, yylex)
		}
	case 14:
		yyDollar = yyS[yypt-10 : yypt+1]
//line ast/grammar.y:146
		{
			yyVAL.funcProc = createFunctionOrProcedure(PFTypeProcedure, yyDollar[1].opt_directive, yyDollar[3].token.literal, yyDollar[5].declarations_method_params, yyDollar[7].opt_export, yyDollar[8].opt_explicit_variables, yyDollar[9].opt_body)
		}
	case 15:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:151
		{
			yyVAL.opt_body = nil
		}
	case 16:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:152
		{
			yyVAL.opt_body = yyDollar[1].body
		}
	case 17:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:156
		{
			yyVAL.body = []Statement{yyDollar[1].stmt}
		}
	case 18:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:157
		{
			if yyDollar[2].token.literal == ":" && len(yyDollar[1].opt_body) > 0 {
				if _, ok := yyDollar[1].opt_body[len(yyDollar[1].opt_body)-1].(*GoToLabelStatement); !ok {
					yylex.Error("semicolon (;) is expected")
				}
			}
			if yyDollar[3].stmt != nil {
				yyVAL.body = append(yyVAL.body, yyDollar[3].stmt)
			}
		}
	case 19:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:170
		{
			yyVAL.stmt = nil
		}
	case 20:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:171
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 21:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:174
		{
			yyVAL.token = yyDollar[1].token
		}
	case 22:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:174
		{
			yyVAL.token = yyDollar[1].token
		}
	case 23:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:178
		{
			yyVAL.opt_explicit_variables = map[string]VarStatement{}
		}
	case 24:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:179
		{
			yyVAL.opt_explicit_variables = yyDollar[1].explicit_variables
		}
	case 25:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:182
		{
			if vars, err := appendVarStatements(map[string]VarStatement{}, yyDollar[2].identifiers); err != nil {
				yylex.Error(err.Error())
			} else {
				yyVAL.explicit_variables = vars
			}
		}
	case 26:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:189
		{
			if vars, err := appendVarStatements(yyDollar[1].explicit_variables, yyDollar[3].identifiers); err != nil {
				yylex.Error(err.Error())
			} else {
				yyVAL.explicit_variables = vars
			}
		}
	case 27:
		yyDollar = yyS[yypt-7 : yypt+1]
//line ast/grammar.y:200
		{
			yyVAL.stmt_if = &IfStatement{
				Expression:  yyDollar[2].stmt,
				TrueBlock:   yyDollar[4].opt_body,
				IfElseBlock: yyDollar[5].opt_elseif_list,
				ElseBlock:   yyDollar[6].opt_else,
			}
		}
	case 28:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:210
		{
			yyVAL.opt_elseif_list = []Statement{}
		}
	case 29:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:211
		{
			yyVAL.opt_elseif_list = append(yyDollar[5].opt_elseif_list, &IfStatement{
				Expression: yyDollar[2].stmt,
				TrueBlock:  yyDollar[4].opt_body,
			})
		}
	case 30:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:219
		{
			yyVAL.opt_else = nil
		}
	case 31:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:220
		{
			yyVAL.opt_else = yyDollar[2].opt_body
		}
	case 32:
		yyDollar = yyS[yypt-8 : yypt+1]
//line ast/grammar.y:223
		{
			yyVAL.stmt = TernaryStatement{
				Expression: yyDollar[3].stmt,
				TrueBlock:  yyDollar[5].stmt,
				ElseBlock:  yyDollar[7].stmt,
			}
		}
	case 33:
		yyDollar = yyS[yypt-6 : yypt+1]
//line ast/grammar.y:232
		{
			setLoopFlag(true, yylex)
		}
	case 34:
		yyDollar = yyS[yypt-9 : yypt+1]
//line ast/grammar.y:232
		{
			yyVAL.stmt_loop = &LoopStatement{
				For:  yyDollar[3].token.literal,
				In:   yyDollar[5].stmt,
				Body: yyDollar[8].opt_body,
			}
			setLoopFlag(false, yylex)
		}
	case 35:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:240
		{
			setLoopFlag(true, yylex)
		}
	case 36:
		yyDollar = yyS[yypt-8 : yypt+1]
//line ast/grammar.y:240
		{
			yyVAL.stmt_loop = &LoopStatement{
				For:  yyDollar[2].stmt,
				To:   yyDollar[4].stmt,
				Body: yyDollar[7].opt_body,
			}
			setLoopFlag(false, yylex)
		}
	case 37:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:248
		{
			setLoopFlag(true, yylex)
		}
	case 38:
		yyDollar = yyS[yypt-6 : yypt+1]
//line ast/grammar.y:248
		{
			yyVAL.stmt_loop = &LoopStatement{
				WhileExpr: yyDollar[2].stmt,
				Body:      yyDollar[5].opt_body,
			}
		}
	case 39:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:257
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 40:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:258
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 41:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:259
		{
			yyVAL.stmt = yyDollar[2].stmt
		}
	case 42:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:262
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 43:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:263
		{
			yyVAL.stmt = yyDollar[1].stmt_if
		}
	case 44:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:264
		{
			yyVAL.stmt = yyDollar[1].stmt_loop
		}
	case 45:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:265
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 46:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:266
		{
			yyVAL.stmt = ContinueStatement{}
			checkLoopOperator(yyDollar[1].token, yylex)
		}
	case 47:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:267
		{
			yyVAL.stmt = BreakStatement{}
			checkLoopOperator(yyDollar[1].token, yylex)
		}
	case 48:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:268
		{
			yyVAL.stmt = ThrowStatement{Param: yyDollar[2].stmt}
			checkThrowParam(yyDollar[1].token, yyDollar[2].stmt, yylex)
		}
	case 49:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:269
		{
			yyVAL.stmt = &ReturnStatement{Param: yyDollar[2].stmt}
			checkReturnParam(yyDollar[2].stmt, yylex)
		}
	case 50:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:272
		{
			yyVAL.stmt = nil
		}
	case 51:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:273
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 52:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:278
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 53:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:279
		{
			yyVAL.stmt = CallChainStatement{Unit: yyDollar[3].stmt, Call: yyDollar[1].stmt}
		}
	case 54:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:285
		{
			yyVAL.stmt = VarStatement{Name: yyDollar[1].token.literal}
		}
	case 55:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:286
		{
			yyVAL.stmt = MethodStatement{Name: yyDollar[1].token.literal, Param: yyDollar[3].exprs}
		}
	case 56:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:287
		{
			yyVAL.stmt = ItemStatement{Object: yyDollar[1].stmt, Item: yyDollar[3].stmt}
		}
	case 57:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:288
		{
			yyVAL.stmt = MethodStatement{Name: yyDollar[1].token.literal, Param: []Statement{yyDollar[2].stmt}}
		}
	case 58:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:289
		{
			yyVAL.stmt = MethodStatement{Name: yyDollar[1].token.literal, Param: []Statement{yyDollar[3].stmt}}
		}
	case 59:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:290
		{
			yyVAL.stmt = &BuiltinFunctionStatement{Name: yyDollar[1].token.literal, Param: yyDollar[3].exprs}
		}
	case 60:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:293
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 61:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:294
		{
			yyVAL.stmt = VarStatement{Name: yyDollar[1].token.literal}
		}
	case 62:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:297
		{
			setTryFlag(true, yylex)
		}
	case 63:
		yyDollar = yyS[yypt-6 : yypt+1]
//line ast/grammar.y:297
		{
			yyVAL.stmt = TryStatement{Body: yyDollar[2].opt_body, Catch: yyDollar[5].opt_body}
			setTryFlag(false, yylex)
		}
	case 64:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:303
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 65:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:304
		{
			yyVAL.stmt = yyDollar[2].stmt
		}
	case 66:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:305
		{
			yyVAL.stmt = &ExpStatement{Operation: OpPlus, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 67:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:306
		{
			yyVAL.stmt = &ExpStatement{Operation: OpMinus, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 68:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:307
		{
			yyVAL.stmt = &ExpStatement{Operation: OpMul, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 69:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:308
		{
			yyVAL.stmt = &ExpStatement{Operation: OpDiv, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 70:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:309
		{
			yyVAL.stmt = &ExpStatement{Operation: OpMod, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 71:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:310
		{
			yyVAL.stmt = &ExpStatement{Operation: OpGt, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 72:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:311
		{
			yyVAL.stmt = &ExpStatement{Operation: OpLt, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 73:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:312
		{
			yyVAL.stmt = &ExpStatement{Operation: OpEq, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 74:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:313
		{
			yyVAL.stmt = &ExpStatement{Operation: OpOr, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 75:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:314
		{
			yyVAL.stmt = &ExpStatement{Operation: OpAnd, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 76:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:315
		{
			yyVAL.stmt = &ExpStatement{Operation: OpNe, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 77:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:316
		{
			yyVAL.stmt = &ExpStatement{Operation: OpLe, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 78:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:317
		{
			yyVAL.stmt = &ExpStatement{Operation: OpGe, Left: yyDollar[1].stmt, Right: yyDollar[3].stmt}
		}
	case 79:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:318
		{
			yyVAL.stmt = not(yyDollar[2].stmt)
		}
	case 80:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:319
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 81:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:320
		{
			yyVAL.stmt = GoToStatement{Label: yyDollar[2].goToLabel}
		}
	case 82:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:323
		{
			yyVAL.stmt = nil
		}
	case 83:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:323
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 84:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:326
		{
			yyVAL.declarations_method_param = *(&ParamStatement{}).Fill(nil, yyDollar[1].token)
		}
	case 85:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:327
		{
			yyVAL.declarations_method_param = *(&ParamStatement{}).Fill(&yyDollar[1].token, yyDollar[2].token)
		}
	case 86:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:328
		{
			yyVAL.declarations_method_param = *(yyVAL.declarations_method_param.DefaultValue(yyDollar[3].stmt))
		}
	case 87:
		yyDollar = yyS[yypt-0 : yypt+1]
//line ast/grammar.y:331
		{
			yyVAL.declarations_method_params = []ParamStatement{}
		}
	case 88:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:332
		{
			yyVAL.declarations_method_params = []ParamStatement{yyDollar[1].declarations_method_param}
		}
	case 89:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:333
		{
			yyVAL.declarations_method_params = append(yyDollar[1].declarations_method_params, yyDollar[3].declarations_method_param)
		}
	case 90:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:341
		{
			yyVAL.stmt = NewObjectStatement{Constructor: yyDollar[2].token.literal}
		}
	case 91:
		yyDollar = yyS[yypt-5 : yypt+1]
//line ast/grammar.y:342
		{
			yyVAL.stmt = NewObjectStatement{Constructor: yyDollar[2].token.literal, Param: yyDollar[4].exprs}
		}
	case 92:
		yyDollar = yyS[yypt-4 : yypt+1]
//line ast/grammar.y:343
		{
			yyVAL.stmt = NewObjectStatement{Param: yyDollar[3].exprs}
		}
	case 93:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:346
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 94:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:347
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 95:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:348
		{
			yyVAL.stmt = unaryMinus(yyDollar[2].stmt)
		}
	case 96:
		yyDollar = yyS[yypt-2 : yypt+1]
//line ast/grammar.y:349
		{
			yyVAL.stmt = yyDollar[2].stmt
		}
	case 97:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:350
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 98:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:351
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 99:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:352
		{
			yyVAL.stmt = yyDollar[1].token.value
		}
	case 100:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:353
		{
			yyVAL.stmt = UndefinedStatement{}
		}
	case 101:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:354
		{
			yyVAL.stmt = yyDollar[1].goToLabel
		}
	case 102:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:355
		{
			if tok, ok := yyDollar[1].stmt.(Token); ok {
				yyVAL.stmt = tok.literal
			} else {
				yyVAL.stmt = yyDollar[1].stmt
			}
		}
	case 103:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:362
		{
			yyVAL.stmt = yyDollar[1].stmt
		}
	case 104:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:365
		{
			yyVAL.goToLabel = &GoToLabelStatement{Name: yyDollar[1].token.literal}
		}
	case 105:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:367
		{
			yyVAL.exprs = []Statement{yyDollar[1].stmt}
		}
	case 106:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:368
		{
			yyVAL.exprs = append(yyVAL.exprs, yyDollar[3].stmt)
		}
	case 107:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:371
		{
			yyVAL.identifiers = []Token{yyDollar[1].token}
		}
	case 108:
		yyDollar = yyS[yypt-3 : yypt+1]
//line ast/grammar.y:372
		{
			yyVAL.identifiers = append(yyVAL.identifiers, yyDollar[3].token)
		}
	case 109:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:375
		{
			yyVAL.token = yyDollar[1].token
		}
	case 110:
		yyDollar = yyS[yypt-1 : yypt+1]
//line ast/grammar.y:376
		{
			yyVAL.token = yyDollar[1].token
		}
	}
	goto yystack /* stack new state and value */
}


***********output***************
lowLit процедура
tName 57348
lowLit командавыполнитькоманду
Identifier КомандаВыполнитьКоманду
lowLit команда
Identifier Команда
lowLit оповещенияпослерачсета
Identifier ОповещенияПослеРачсета
lowLit новый
tName 57373
lowLit описаниеоповещения
Identifier ОписаниеОповещения
lowLit этотобъект
Identifier ЭтотОбъект
lowLit выполнитьобработкуоповещения
tName 57390
lowLit оповещенияпослерачсета
Identifier ОповещенияПослеРачсета
lowLit конецпроцедуры
tName 57350
lowLit процедура
tName 57348
lowLit послевыполнениярасчета
Identifier ПослеВыполненияРасчета
lowLit резульат
Identifier Резульат
lowLit параметры
Identifier Параметры
lowLit экспорт
tName 57386
lowLit сообщить
Identifier Сообщить
lowLit сокрлп
Identifier СокрЛП
lowLit резульат
Identifier Резульат
lowLit конецпроцедуры
tName 57350
{"Name":"","Body":[{"ExplicitVariables":{},"Name":"КомандаВыполнитьКоманду","Directive":"\u0026НаКлиенте","Body":[{"Left":{"Name":"ОповещенияПослеРачсета"},"Right":{"Constructor":"ОписаниеОповещения","Param":["ПослеВыполненияРасчета",{"Name":"ЭтотОбъект"}]},"Operation":4},{"Name":"ВыполнитьОбработкуОповещения","Param":[{"Name":"ОповещенияПослеРачсета"},10]}],"Params":[{"Name":"Команда"}],"Type":1,"Export":false},{"ExplicitVariables":{},"Name":"ПослеВыполненияРасчета","Directive":"\u0026НаКлиенте","Body":[{"Name":"Сообщить","Param":[{"Left":"Результат расчета=","Right":{"Name":"СокрЛП","Param":[{"Name":"Резульат"}]},"Operation":0}]}],"Params":[{"Name":"Резульат"},{"Name":"Параметры"}],"Type":1,"Export":true}]}
Walk ModuleStatement
StatementWalk: 2
 walkHelper parent: *ast.FunctionOrProcedure <nil> 1
 walkHelper statements: 2 []ast.Statement [0x144e080 0x144e0c0]
 walkHelper item: 0 *ast.FunctionOrProcedure &{map[] КомандаВыполнитьКоманду &НаКлиенте [0x14502a0 0x14502b8] [{<nil> Команда false}] 1 false}
 FunctionOrProcedure
  walkHelper parent: *ast.FunctionOrProcedure &{map[] КомандаВыполнитьКоманду &НаКлиенте [0x14502a0 0x14502b8] [{<nil> Команда false}] 1 false} 2
  walkHelper statements: 2 []ast.Statement [0x14502a0 0x14502b8]
  walkHelper item: 0 *ast.ExpStatement &{{ОповещенияПослеРачсета {false false false}} {ОписаниеОповещения [ПослеВыполненияРасчета {ЭтотОбъект {false false false}}]} = {false false false}}
  ExpStatement
   walkHelper parent: *ast.FunctionOrProcedure &{map[] КомандаВыполнитьКоманду &НаКлиенте [0x14502a0 0x14502b8] [{<nil> Команда false}] 1 false} 3
   walkHelper statements: 1 []ast.Statement [{ОписаниеОповещения [ПослеВыполненияРасчета {ЭтотОбъект {false false false}}]}]
   walkHelper item: 0 ast.NewObjectStatement {ОписаниеОповещения [ПослеВыполненияРасчета {ЭтотОбъект {false false false}}]}
   callBack *ast.FunctionOrProcedure {ОписаниеОповещения [ПослеВыполненияРасчета {ЭтотОбъект {false false false}}]}
Walk FunctionOrProcedure КомандаВыполнитьКоманду
Walk statement *ast.Statement 0x1428708

Функция/Процедура: КомандаВыполнитьКоманду
  Export: false
  Type: 1

Statement тип: ast.NewObjectStatement
  Значение: {Constructor:ОписаниеОповещения Param:[ПослеВыполненияРасчета {Name:ЭтотОбъект addStatementField:{unaryMinus:false unaryPlus:false not:false}}]}
------------------------
    walkHelper parent: *ast.FunctionOrProcedure &{map[] КомандаВыполнитьКоманду &НаКлиенте [0x14502a0 0x14502b8] [{<nil> Команда false}] 1 false} 4
    walkHelper statements: 1 []ast.Statement [{ОповещенияПослеРачсета {false false false}}]
    walkHelper item: 0 ast.VarStatement {ОповещенияПослеРачсета {false false false}}     
    callBack *ast.FunctionOrProcedure {ОповещенияПослеРачсета {false false false}}       
Walk FunctionOrProcedure КомандаВыполнитьКоманду
Walk statement *ast.Statement 0x1428758

Функция/Процедура: КомандаВыполнитьКоманду
  Export: false
  Type: 1

Statement тип: ast.VarStatement
  Значение: {Name:ОповещенияПослеРачсета addStatementField:{unaryMinus:false unaryPlus:false not:false}}
------------------------
  callBack *ast.FunctionOrProcedure &{{ОповещенияПослеРачсета {false false false}} {ОписаниеОповещения [ПослеВыполненияРасчета {ЭтотОбъект {false false false}}]} = {false false false}}
Walk FunctionOrProcedure КомандаВыполнитьКоманду
Walk statement *ast.Statement 0x1408110

Функция/Процедура: КомандаВыполнитьКоманду
  Export: false
  Type: 1

Statement тип: *ast.ExpStatement
  Значение: &{Left:{Name:ОповещенияПослеРачсета addStatementField:{unaryMinus:false unaryPlus:false not:false}} Right:{Constructor:ОписаниеОповещения Param:[ПослеВыполненияРасчета {Name:ЭтотОбъект addStatementField:{unaryMinus:false unaryPlus:false not:false}}]} Operation:= addStatementField:{unaryMinus:false unaryPlus:false not:false}}
------------------------
  walkHelper item: 1 *ast.BuiltinFunctionStatement &{ВыполнитьОбработкуОповещения [{ОповещенияПослеРачсета {false false false}} 10]}
  callBack *ast.FunctionOrProcedure &{ВыполнитьОбработкуОповещения [{ОповещенияПослеРачсета {false false false}} 10]}
Walk FunctionOrProcedure КомандаВыполнитьКоманду
Walk statement *ast.Statement 0x1408118

Функция/Процедура: КомандаВыполнитьКоманду
  Export: false
  Type: 1

Statement тип: *ast.BuiltinFunctionStatement
  Значение: &{Name:ВыполнитьОбработкуОповещения Param:[{Name:ОповещенияПослеРачсета addStatementField:{unaryMinus:false unaryPlus:false not:false}} 10]}
------------------------
 callBack *ast.FunctionOrProcedure &{map[] КомандаВыполнитьКоманду &НаКлиенте [0x14502a0 0x14502b8] [{<nil> Команда false}] 1 false}
Walk FunctionOrProcedure КомандаВыполнитьКоманду
Walk statement *ast.Statement 0x1408130

Функция/Процедура: КомандаВыполнитьКоманду
  Export: false
  Type: 1

Statement тип: *ast.FunctionOrProcedure
  FunctionOrProcedure: &{map[] КомандаВыполнитьКоманду &НаКлиенте [0x14502a0 0x14502b8] [{<nil> Команда false}] 1 false}
------------------------
 walkHelper item: 1 *ast.FunctionOrProcedure &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true}
 FunctionOrProcedure
     walkHelper parent: *ast.FunctionOrProcedure &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true} 5
     walkHelper statements: 1 []ast.Statement [{Сообщить [0x1450300] {false false false}}]
     walkHelper item: 0 ast.MethodStatement {Сообщить [0x1450300] {false false false}}   
     MethodStatement
      walkHelper parent: *ast.FunctionOrProcedure &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true} 6
      walkHelper statements: 1 []ast.Statement [0x1450300]
      walkHelper item: 0 *ast.ExpStatement &{Результат расчета= {СокрЛП [{Резульат {false false false}}] {false false false}} + {false false false}}
      ExpStatement
       walkHelper parent: *ast.FunctionOrProcedure &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true} 7
       walkHelper statements: 1 []ast.Statement [{СокрЛП [{Резульат {false false false}}] {false false false}}]
       walkHelper item: 0 ast.MethodStatement {СокрЛП [{Резульат {false false false}}] {false false false}}
       MethodStatement
        walkHelper parent: *ast.FunctionOrProcedure &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true} 8
        walkHelper statements: 1 []ast.Statement [{Резульат {false false false}}]        
        walkHelper item: 0 ast.VarStatement {Резульат {false false false}}
        callBack *ast.FunctionOrProcedure {Резульат {false false false}}
Walk FunctionOrProcedure ПослеВыполненияРасчета
Walk statement *ast.Statement 0x14281c8

Функция/Процедура: ПослеВыполненияРасчета
  Export: true
  Type: 1

Statement тип: ast.VarStatement
  Значение: {Name:Резульат addStatementField:{unaryMinus:false unaryPlus:false not:false}}
------------------------
       callBack *ast.FunctionOrProcedure {СокрЛП [{Резульат {false false false}}] {false false false}}
Walk FunctionOrProcedure ПослеВыполненияРасчета
Walk statement *ast.Statement 0x14288f0

Функция/Процедура: ПослеВыполненияРасчета
  Export: true
  Type: 1

Statement тип: ast.MethodStatement
  Имя метода: СокрЛП
  Аргументы: 0x563be0
------------------------
         walkHelper parent: *ast.FunctionOrProcedure &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true} 9
         walkHelper statements: 1 []ast.Statement [Результат расчета=]
         walkHelper item: 0 string Результат расчета=
         callBack *ast.FunctionOrProcedure Результат расчета=
Walk FunctionOrProcedure ПослеВыполненияРасчета
Walk statement *ast.Statement 0x14289a8

Функция/Процедура: ПослеВыполненияРасчета
  Export: true
  Type: 1

Statement тип: string
  Значение: Результат расчета=
------------------------
      callBack *ast.FunctionOrProcedure &{Результат расчета= {СокрЛП [{Резульат {false false false}}] {false false false}} + {false false false}}
Walk FunctionOrProcedure ПослеВыполненияРасчета
Walk statement *ast.Statement 0x14281d0

Функция/Процедура: ПослеВыполненияРасчета
  Export: true
  Type: 1

Statement тип: *ast.ExpStatement
  Значение: &{Left:Результат расчета= Right:{Name:СокрЛП Param:[{Name:Резульат addStatementField:{unaryMinus:false unaryPlus:false not:false}}] addStatementField:{unaryMinus:false unaryPlus:false not:false}} Operation:+ addStatementField:{unaryMinus:false unaryPlus:false not:false}}
------------------------
     callBack *ast.FunctionOrProcedure {Сообщить [0x1450300] {false false false}}        
Walk FunctionOrProcedure ПослеВыполненияРасчета
Walk statement *ast.Statement 0x14281d8

Функция/Процедура: ПослеВыполненияРасчета
  Export: true
  Type: 1

Statement тип: ast.MethodStatement
  Имя метода: Сообщить
  Аргументы: 0x563be0
------------------------
 callBack *ast.FunctionOrProcedure &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true}
Walk FunctionOrProcedure ПослеВыполненияРасчета
Walk statement *ast.Statement 0x1408138

Функция/Процедура: ПослеВыполненияРасчета
  Export: true
  Type: 1

Statement тип: *ast.FunctionOrProcedure
  FunctionOrProcedure: &{map[] ПослеВыполненияРасчета &НаКлиенте [{Сообщить [0x1450300] {false false false}}] [{<nil> Резульат false} {<nil> Параметры false}] 1 true}